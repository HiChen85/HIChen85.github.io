{"title":"DataStructure&Algorithm-02","uid":"90b930c19317609fdd990e20fdd0d904","slug":"DataStructure-Algorithm-02","date":"2021-09-22T06:30:43.000Z","updated":"2021-09-24T04:32:36.602Z","comments":true,"path":"api/articles/DataStructure-Algorithm-02.json","keywords":null,"cover":"/img/6.jpg","content":"<h1 id=\"数据结构与算法-02\"><a href=\"#数据结构与算法-02\" class=\"headerlink\" title=\"数据结构与算法 02\"></a>数据结构与算法 02</h1><h2 id=\"分而治之-Divide-amp-Conquer-思想\"><a href=\"#分而治之-Divide-amp-Conquer-思想\" class=\"headerlink\" title=\"分而治之(Divide &amp; Conquer) 思想\"></a>分而治之(Divide &amp; Conquer) 思想</h2><p>分而治之是一种递归式解决问题的方法. 涉及到递归的问题通常都有两个条件</p>\n<ol>\n<li>确定一个基线条件, 或者称为递归结束的条件</li>\n<li>确定递归条件. 在分而治之的思想中, 这一步需要缩小原有问题的规模. </li>\n</ol>\n<p><strong>提示:, 在编写和数组有关的递归函数时, 基线条件通常是数组为空或者只有一个元素的时候, 当陷入困境时,请检查你的基线条件是否符合这样的设计</strong></p>\n<p><strong>在分治方法中, 将问题分割成等长的子问题是较为理想的方式</strong></p>\n<h3 id=\"分治算法的经典应用—快速排序\"><a href=\"#分治算法的经典应用—快速排序\" class=\"headerlink\" title=\"分治算法的经典应用—快速排序\"></a>分治算法的经典应用—快速排序</h3><h4 id=\"简单快速排序\"><a href=\"#简单快速排序\" class=\"headerlink\" title=\"简单快速排序\"></a>简单快速排序</h4><p>快速排序的思想是选取一个基准值, 通过一轮分割,将数据分为三块,小于基准值,基准值和大与基准值三部分,当分割结束后,基准值就出现在了它合适的排序位置. 接着对于剩下的两部分继续重复刚才的步骤,直到每次的基准值都在合适的排序为,当整个流程结束,所有的元素自然都会被排好序. 不断重复的过程同时也是分治算法减小问题规模的过程,因此快排是一个分治算法的经典应用</p>\n<p>对拿到的数据,选取一个基准值,然后维护两个指针,一个指向最左端,一个指向最右端,接着开始循环遍历. 当选取的基准值在最左端时, 第一轮就先从最右端开始, 当选取的基准值为最后一个元素,就从最左端开始.</p>\n<p>假设选取的基准值为第一个元素, 从右端开始找, 找到一个比基准值小的数据时, 指针停止移动. 左端指针开始移动,尝试寻找一个比基准值大的数据, 找到后指针停止移动, 并交换左右指针. </p>\n<p>交换完成后再继续重复刚才的步骤,知道左右指针相遇,循环停止. 那么此时左右指针所在的位置,就是基准值理应存在的排序位置.将其与基准值进行交换,并结束分割.</p>\n<p>对于分割出的大于和小于基准值的区间重复整个分割的步骤,使所有的数据都能在其相对的排序为,当整个流程结束,数据自然排序完成.</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">QuickSort</span><span class=\"token punctuation\">(</span>data <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n\t<span class=\"token keyword\">if</span> <span class=\"token function\">len</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;=</span> <span class=\"token number\">1</span> <span class=\"token punctuation\">&#123;</span>\n\t\t<span class=\"token keyword\">return</span>\n\t<span class=\"token punctuation\">&#125;</span>\n\n\tpivot <span class=\"token operator\">:=</span> <span class=\"token number\">0</span>\n\n\tleft<span class=\"token punctuation\">,</span> right <span class=\"token operator\">:=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token function\">len</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span><span class=\"token operator\">-</span><span class=\"token number\">1</span>\n\n\t<span class=\"token keyword\">for</span> left <span class=\"token operator\">&lt;</span> right <span class=\"token punctuation\">&#123;</span>\n\t\t<span class=\"token keyword\">if</span> data<span class=\"token punctuation\">[</span>right<span class=\"token punctuation\">]</span> <span class=\"token operator\">>=</span> data<span class=\"token punctuation\">[</span>pivot<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">&#123;</span>\n\t\t\tright<span class=\"token operator\">--</span>\n\t\t\t<span class=\"token keyword\">continue</span>\n\t\t<span class=\"token punctuation\">&#125;</span>\n\t\t<span class=\"token keyword\">if</span> data<span class=\"token punctuation\">[</span>left<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;=</span> data<span class=\"token punctuation\">[</span>pivot<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">&#123;</span>\n\t\t\tleft<span class=\"token operator\">++</span>\n\t\t\t<span class=\"token keyword\">continue</span>\n\t\t<span class=\"token punctuation\">&#125;</span>\n\t\tdata<span class=\"token punctuation\">[</span>left<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> data<span class=\"token punctuation\">[</span>right<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> data<span class=\"token punctuation\">[</span>right<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> data<span class=\"token punctuation\">[</span>left<span class=\"token punctuation\">]</span>\n\t<span class=\"token punctuation\">&#125;</span>\n\tdata<span class=\"token punctuation\">[</span>pivot<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> data<span class=\"token punctuation\">[</span>left<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> data<span class=\"token punctuation\">[</span>left<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> data<span class=\"token punctuation\">[</span>pivot<span class=\"token punctuation\">]</span>\n\tpivot <span class=\"token operator\">=</span> left\n\n\t<span class=\"token function\">QuickSort</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">[</span><span class=\"token punctuation\">:</span>pivot<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token function\">QuickSort</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">[</span>pivot<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">:</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<h3 id=\"三向切分快速排序\"><a href=\"#三向切分快速排序\" class=\"headerlink\" title=\"三向切分快速排序\"></a>三向切分快速排序</h3><p>三向切分的提出是因为当快速排序遇到很多重复元素进行递归时,性能骤降,所以为了提升算法性能而改进.</p>\n<p>简单的三向切分的应用就是**<a href=\"https://leetcode-cn.com/problems/sort-colors/\">荷兰国旗</a>**问题.</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">sortColors</span><span class=\"token punctuation\">(</span>nums <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span>  <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token comment\">// 0 红色</span>\n  <span class=\"token comment\">// 1 白色</span>\n  <span class=\"token comment\">// 2 蓝色</span>\n  <span class=\"token comment\">// 颜色排序也是一个典型的快速排序，基础快速排序也可以完成， 但是性能不佳</span>\n  <span class=\"token comment\">// 因而可以使用三向切分快速排序, 三向切分的思想是利用两个额外的指针，把</span>\n  <span class=\"token comment\">// 每一轮与基准值相同的元素集中在当前数据的中部，小于基准值的元素置于左</span>\n  <span class=\"token comment\">// 侧，大于基准值的元素置于右侧。在切分完成之后，这个算法就已经自动的把</span>\n  <span class=\"token comment\">// 当前的基准值放置在了适合它顺序的位置。接下来对于小于它的部分以及大于</span>\n  <span class=\"token comment\">// 它的部分递归调用本算法，本质上是利用分治的思想，最终完成排序。</span>\n  <span class=\"token comment\">// 快速排序是一个分治思想的典型应用。 应熟练掌握</span>\n\n  <span class=\"token comment\">// 对于数组元素来说，分治法的基准条件(结束递归的条件)就是当数组为空或者只有一个元素的时候</span>\n  <span class=\"token keyword\">if</span> <span class=\"token function\">len</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;</span> <span class=\"token number\">2</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">return</span>\n  <span class=\"token punctuation\">&#125;</span>\n\n  <span class=\"token comment\">// pivot 基准值， 一般选取当前数据的第一个元素，可优化的空间是选择使用三数中值法</span>\n  pivot <span class=\"token operator\">:=</span> nums<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span>\n\n  <span class=\"token comment\">// 两个指针指向小于等于活大于等于基准值的元素</span>\n  lt<span class=\"token punctuation\">,</span> gt <span class=\"token operator\">:=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token function\">len</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">)</span><span class=\"token operator\">-</span><span class=\"token number\">1</span>\n\n  <span class=\"token comment\">// i 为循环变量，指向当前数据的第二个元素，用于遍历当前数据，i 到 gt 的区间内都是待排序数据，一旦当前的 i</span>\n  <span class=\"token comment\">// 指向的元素与基准值相等时，则 i 前进，lt, gt 不动。缩小待排序区间</span>\n  <span class=\"token comment\">// 若 i 指向的元素比基准值小， 则与 lt 指向的元素交换位置，然后 lt 前移一位，</span>\n  <span class=\"token comment\">// 这就表示把小于基准值的元素统一放在了 [0,lt) 的区间内，然后 i 前移一位</span>\n  <span class=\"token comment\">// 若 i 指向的元素大于基准值， 则与 gt 指向的元素交换位置。本次交换能够确保的</span>\n  <span class=\"token comment\">// 仅仅是 i 指向的元素被交换到了数据的最右端，无法保证gt 指向的元素与基准值的</span>\n  <span class=\"token comment\">// 大小关系，因此，交换后，gt 前移(向左移动，因其在元素尾端)，而 i 不前移，</span>\n  <span class=\"token comment\">// 交换后重新对 i 处(交换后,实际为原本gt处)的元素重新进行一次判断后再移动</span>\n  <span class=\"token comment\">// 之所以使用 i&lt;=gt 是因为[i,gt]之间都是待排序区间，当 i 与 gt 相等时，</span>\n  <span class=\"token comment\">// 当前的 i 仍是一个未排序的元素，还需一次循环来确认其归属</span>\n  <span class=\"token keyword\">for</span> i<span class=\"token operator\">:=</span> lt <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> gt<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">if</span> nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> pivot <span class=\"token punctuation\">&#123;</span>\n      nums<span class=\"token punctuation\">[</span>lt<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>nums<span class=\"token punctuation\">[</span>lt<span class=\"token punctuation\">]</span>\n      lt<span class=\"token operator\">++</span>\n      i<span class=\"token operator\">++</span>\n    <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> pivot <span class=\"token punctuation\">&#123;</span>\n      nums<span class=\"token punctuation\">[</span>gt<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> nums<span class=\"token punctuation\">[</span>gt<span class=\"token punctuation\">]</span>\n      gt<span class=\"token operator\">--</span>\n    <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">&#123;</span>\n      i<span class=\"token operator\">++</span>\n    <span class=\"token punctuation\">&#125;</span>\n  <span class=\"token punctuation\">&#125;</span>\n\n  <span class=\"token comment\">// 当前轮对数据的处理结束后，得到三个区域 [0, lt), [lt,gt], (gt,len(nums)-1]</span>\n  <span class=\"token comment\">// 中间部分为经过分割后，与当前所选基准值相等的元素， 左边为小于基准值的元素，右边为</span>\n  <span class=\"token comment\">// 大于基准值的元素，现在只需对这两个部分(相对基准值的关系确定，但内部关系扔为确认)</span>\n  <span class=\"token comment\">// 需要再次对其进行梳理，递归完成即可</span>\n  <span class=\"token comment\">// 需要注意的是 gt 在分割过程结束后，最终指向的一定是与基准值相等的最后一个元素</span>\n  <span class=\"token comment\">// 过程可以自行手绘过程理解一下。所以在对右半部分处理时， gt+1 才是大于基准值的第一个元素</span>\n  <span class=\"token function\">sortColors</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span><span class=\"token punctuation\">:</span>lt<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n  <span class=\"token function\">sortColors</span><span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">[</span>gt<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">:</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n\n\n<span class=\"token punctuation\">&#125;</span>\n\n作者：hichen85\n链接：https<span class=\"token punctuation\">:</span><span class=\"token operator\">/</span><span class=\"token operator\">/</span>leetcode<span class=\"token operator\">-</span>cn<span class=\"token punctuation\">.</span>com<span class=\"token operator\">/</span>problems<span class=\"token operator\">/</span>sort<span class=\"token operator\">-</span>colors<span class=\"token operator\">/</span>solution<span class=\"token operator\">/</span>golang<span class=\"token operator\">-</span>shi<span class=\"token operator\">-</span>xian<span class=\"token operator\">-</span>he<span class=\"token operator\">-</span>lan<span class=\"token operator\">-</span>guo<span class=\"token operator\">-</span>qi<span class=\"token operator\">-</span>wen<span class=\"token operator\">-</span>ti<span class=\"token operator\">-</span>by<span class=\"token operator\">-</span>xce4t<span class=\"token operator\">/</span>\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n","feature":true,"text":"数据结构与算法 02分而治之(Divide &amp; Conquer) 思想分而治之是一种递归式解决问题的方法. 涉及到递归的问题通常都有两个条件 确定一个基线条件, 或者称为递归结束的条件 确定递归条件. 在分而治之的思想中, 这一步需要缩小原有问题的规模. 提示:, 在编写...","link":"","photos":[],"count_time":{"symbolsCount":"3.2k","symbolsTime":"3 mins."},"categories":[{"name":"DataStructure","slug":"DataStructure","count":2,"path":"api/categories/DataStructure.json"}],"tags":[{"name":"DataStructure","slug":"DataStructure","count":2,"path":"api/tags/DataStructure.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-02\"><span class=\"toc-text\">数据结构与算法 02</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%88%86%E8%80%8C%E6%B2%BB%E4%B9%8B-Divide-amp-Conquer-%E6%80%9D%E6%83%B3\"><span class=\"toc-text\">分而治之(Divide &amp; Conquer) 思想</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95%E7%9A%84%E7%BB%8F%E5%85%B8%E5%BA%94%E7%94%A8%E2%80%94%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">分治算法的经典应用—快速排序</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%AE%80%E5%8D%95%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">简单快速排序</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%89%E5%90%91%E5%88%87%E5%88%86%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">三向切分快速排序</span></a></li></ol></li></ol></li></ol>","author":{"name":"Hccc丶","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"曾经沧海难为水, 除却巫山不是云<br/>取次花丛懒回顾, 半缘修道半缘君","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"github":{"icon":"/svg/github.svg","link":"https://github.com/HiChen85"},"bilibili":{"icon":"/svg/logo.svg","link":"https://space.bilibili.com/512394874"}}}},"mapped":true,"prev_post":{},"next_post":{"title":"DataStructure 01","uid":"2e282140550dbaba095df242e62ffa5e","slug":"DataStructure-Algorithm-01","date":"2021-09-18T16:42:03.000Z","updated":"2021-09-20T08:27:59.773Z","comments":true,"path":"api/articles/DataStructure-Algorithm-01.json","keywords":null,"cover":"/img/2.jpg","text":"DataStructure 01单链表单链表是线性表的一种链式存储结构, 具有单向性,只能从前向后遍历. 单链表的特性: 单链表的尾结点的 next 域为空 做添加(在尾结点添加), 插入(任意位置), 删除(任意位置)比较容易, 查询遍历来说比较耗时. 单链表的golang 实...","link":"","photos":[],"count_time":{"symbolsCount":"2.5k","symbolsTime":"2 mins."},"categories":[{"name":"DataStructure","slug":"DataStructure","count":2,"path":"api/categories/DataStructure.json"}],"tags":[{"name":"DataStructure","slug":"DataStructure","count":2,"path":"api/tags/DataStructure.json"}],"author":{"name":"Hccc丶","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"曾经沧海难为水, 除却巫山不是云<br/>取次花丛懒回顾, 半缘修道半缘君","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"github":{"icon":"/svg/github.svg","link":"https://github.com/HiChen85"},"bilibili":{"icon":"/svg/logo.svg","link":"https://space.bilibili.com/512394874"}}}},"feature":true}}