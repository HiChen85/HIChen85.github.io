{"title":"Golang Tutorial 4","uid":"ed56a0be6c67a53488e6ffd0f75904e2","slug":"Golang-Tutorial-4","date":"2021-09-05T22:06:48.000Z","updated":"2021-09-12T11:08:53.333Z","comments":true,"path":"api/articles/Golang-Tutorial-4.json","keywords":null,"cover":"/img/4.jpg","content":"<h1 id=\"Golang-Tutorial-4\"><a href=\"#Golang-Tutorial-4\" class=\"headerlink\" title=\"Golang Tutorial 4\"></a>Golang Tutorial 4</h1><h2 id=\"切片-slice\"><a href=\"#切片-slice\" class=\"headerlink\" title=\"切片(slice)\"></a>切片(slice)</h2><p>Golang 中的切片是对数组一个连续片段的引用, 因此是引用类型. 这个连续的片段可以是整个数组,也可以是由开发者指定的开始和结束索引限定的一段连续片段. 从集合的角度来看,若数组是一个元素集合,则切片就是它的一系列非空子集.</p>\n<p>既然是数组的引用,那么切片本身也具备数组的一些性质.另外,切片同时也具备一些数组不具备的特质,比如可以向切片中增加元素.</p>\n<p>切片同时提供了可以计算切片容量的函数 cap(), 如果切片是由数组创建的, 计算方法是从切片的起始元素到数组末尾的长度.</p>\n<h3 id=\"创建切片的方式\"><a href=\"#创建切片的方式\" class=\"headerlink\" title=\"创建切片的方式\"></a>创建切片的方式</h3><ul>\n<li><h4 id=\"make创建\"><a href=\"#make创建\" class=\"headerlink\" title=\"make创建\"></a>make创建</h4><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">&#x2F;&#x2F; 创建格式: make(type, len[, cap])\n&#x2F;&#x2F; 创建一个长度为 5, 容量为 10 的切片\n&#x2F;&#x2F; 切片容量代表的是当切片元素达到 5 时, 继续往后最多可添加的元素个数\n&#x2F;&#x2F; 当再添加五个元素后,切片容量达到最大,此时若再向其中添加元素,则需要重新构建\n&#x2F;&#x2F; 新的切片.因此, 在一些结构体中,可能需要使用指针接收者来指向原始的切片数据\ns1 :&#x3D; make([]int, 5, 10)\n\n&#x2F;&#x2F; 切片的遍历\nfor idx, value :&#x3D; range s1 &#123;\n  fmt.Println(idx, value)\n&#125;</code></pre></li>\n<li><h4 id=\"显式初始化\"><a href=\"#显式初始化\" class=\"headerlink\" title=\"显式初始化\"></a>显式初始化</h4><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">var sli1 &#x3D; []int&#123;1,2,3,4,4&#125;\nsli2 :&#x3D; []string&#123;&quot;zhangsan&quot;, &quot;lisi&quot;, &quot;wangwu&quot;&#125;</code></pre></li>\n<li><h4 id=\"从数组中创建\"><a href=\"#从数组中创建\" class=\"headerlink\" title=\"从数组中创建\"></a>从数组中创建</h4><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">arr1 :&#x3D; [...]int&#123;1,2,3,4,5&#125;\nsli3 :&#x3D; arr1[1:3] &#x2F;&#x2F; 方括号中的索引是包含左边不包含右边的\n&#x2F;&#x2F; sli3 的输出结果是 2 3</code></pre></li>\n</ul>\n<h3 id=\"copy函数\"><a href=\"#copy函数\" class=\"headerlink\" title=\"copy函数\"></a>copy函数</h3><p>利用 copy 函数可以对一个已有的切片进行拷贝,具体语法如下</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">rst :&#x3D; make([]string, 5, 10)\ntemp :&#x3D; []string&#123;&quot;Beijing&quot;, &quot;London&quot;, &quot;Glasgow&quot;&#125;\n&#x2F;&#x2F; copy 函数会将后续参数中的元素全部复制到第一个参数的切片中\n&#x2F;&#x2F; copy(dest, src) &#x2F;&#x2F; 将 src 中的元素拷贝到 dest 中\ncopy(rst, temp)</code></pre>\n\n<h3 id=\"append-函数\"><a href=\"#append-函数\" class=\"headerlink\" title=\"append 函数\"></a>append 函数</h3><p>append 函数会将0 个或者多个具有相同类型的元素追加到已有的切片中,若超出了切片的容量时, 切片会发生扩容, append 会重新分配一块<strong>新的内存区域来存放整个新的切片</strong>.<strong>此时旧的切片将保持扩容到最大容量时的数据</strong>. append 函数总是成功返回的,除非内存消耗殆尽.</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">s1 :&#x3D; make([]int, 2, 4)\nvar s2 []int\nfmt.Printf(&quot;%p \\n&quot;, s2)\t&#x2F;&#x2F;打印初始的s2 地址,由于未初始化,并未分配实际的内存地址\nfor i :&#x3D; 0; i &lt; 5; i++ &#123;\t&#x2F;&#x2F; 此处设置 5 是为了测试当容量超出原始 slice 的容量时,看append 函数是否会对 slice 进行扩容并分配新的内存空间给新变量\n  if i &gt;&#x3D; len(s1) &amp;&amp; i &lt; cap(s1) &#123;\n    fmt.Println(&quot;长度不足,在 slice 容量内扩容&quot;)\n    s1 &#x3D; append(s1, i)\n    fmt.Printf(&quot;%p %v \\n&quot;, s1, s1[i])\n  &#125; else if i &lt; len(s1) &#123;\n    fmt.Println(&quot;长度足够, 直接对 slice 元素赋值&quot;)\n    s1[i] &#x3D; i\n    fmt.Printf(&quot;%p %v \\n&quot;, s1, s1[i])\n  &#125; else &#123;\n    fmt.Println(&quot;元素个数已超出原始 slice 容量, append 函数重新分配内存空间给新的 slice&quot;)\n    s2 &#x3D; append(s1, i)\n    fmt.Printf(&quot;%p %v\\n&quot;, s2, s2[i])\n    fmt.Printf(&quot;len(s2)&#x3D;%v cap(s2)&#x3D;%v \\n&quot;, len(s2), cap(s2))\n  &#125;\n&#125;\nfmt.Printf(&quot;%p %v\\n&quot;, s1, s1)\nfmt.Printf(&quot;%p %v\\n&quot;, s2, s2)</code></pre>\n\n<h3 id=\"slice-的扩容规则\"><a href=\"#slice-的扩容规则\" class=\"headerlink\" title=\"slice 的扩容规则\"></a>slice 的扩容规则</h3><p>根据上述代码的输出结果,最终 cap=4 的 s1 在容量不足进行扩充后,s2 容量为 8.因此扩容规则为 double 原始 slice 的容量 capacity.</p>\n<h3 id=\"new-函数和-make-函数的区别\"><a href=\"#new-函数和-make-函数的区别\" class=\"headerlink\" title=\"new 函数和 make 函数的区别\"></a>new 函数和 make 函数的区别</h3><p>new 函数会分配指定类型的指针给变量. 多用于结构体类型和数组等值类型变量, 相当于<code>&amp;T&#123;&#125;</code>,其中 T 可以是<code>[5]int</code>, <code>[6]string</code>以及 <code>&amp;Student&#123;&#125;</code>等自定义类型.</p>\n<p>new 函数创建的指针变量值为 <code>0x0</code>, 若为 silce, 则 <code>len=0, cap=0</code>. 变量指向的实际 slice 为一个<code>nil</code>.而 slice 的 nil 输出为一个<code>[]</code>.</p>\n<p>make 会初始化一个slice 变量, 并分配实际内存, 创建对应类型的初值. 在不指定 cap 的时候,cap 会与 len 相等.</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">temp1 :&#x3D; new([]int)\nfmt.Printf(&quot;%p %v %v %v\\n&quot;, *temp1, *temp1, len(*temp1), cap(*temp1))\nfmt.Println(*temp1 &#x3D;&#x3D; nil)\ntemp2 :&#x3D; make([]int, 5)\nfmt.Printf(&quot;%p %v %v %v \\n&quot;, temp2, temp2, len(temp2), cap(temp2))</code></pre>\n\n<p>可以根据上述代码自行检验结果.</p>\n","feature":true,"text":"Golang Tutorial 4切片(slice)Golang 中的切片是对数组一个连续片段的引用, 因此是引用类型. 这个连续的片段可以是整个数组,也可以是由开发者指定的开始和结束索引限定的一段连续片段. 从集合的角度来看,若数组是一个元素集合,则切片就是它的一系列非空子集....","link":"","photos":[],"count_time":{"symbolsCount":"2.9k","symbolsTime":"3 mins."},"categories":[{"name":"Golang","slug":"Golang","count":4,"path":"api/categories/Golang.json"}],"tags":[{"name":"Programming Language","slug":"Programming-Language","count":4,"path":"api/tags/Programming-Language.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Golang-Tutorial-4\"><span class=\"toc-text\">Golang Tutorial 4</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%88%87%E7%89%87-slice\"><span class=\"toc-text\">切片(slice)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%9B%E5%BB%BA%E5%88%87%E7%89%87%E7%9A%84%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">创建切片的方式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#make%E5%88%9B%E5%BB%BA\"><span class=\"toc-text\">make创建</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%98%BE%E5%BC%8F%E5%88%9D%E5%A7%8B%E5%8C%96\"><span class=\"toc-text\">显式初始化</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BB%8E%E6%95%B0%E7%BB%84%E4%B8%AD%E5%88%9B%E5%BB%BA\"><span class=\"toc-text\">从数组中创建</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#copy%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">copy函数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#append-%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">append 函数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#slice-%E7%9A%84%E6%89%A9%E5%AE%B9%E8%A7%84%E5%88%99\"><span class=\"toc-text\">slice 的扩容规则</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#new-%E5%87%BD%E6%95%B0%E5%92%8C-make-%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">new 函数和 make 函数的区别</span></a></li></ol></li></ol></li></ol>","author":{"name":"Hccc丶","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"曾经沧海难为水, 除却巫山不是云<br/>取次花丛懒回顾, 半缘修道半缘君","socials":{"github":{"link":"https://github.com/HiChen85"},"twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/logo.svg","link":"https://space.bilibili.com/512394874"}}}},"mapped":true,"prev_post":{},"next_post":{"title":"Golang Tutorial 3","uid":"3983d1b06f9cc59a424cf4b8b973001f","slug":"Golang-Tutorial-3","date":"2021-09-03T07:30:17.000Z","updated":"2021-09-12T00:55:53.899Z","comments":true,"path":"api/articles/Golang-Tutorial-3.json","keywords":null,"cover":"/img/3.jpg","text":"Golang Tutorial 3数组(Array)在 golang 中,数组是值类型变量,当作为参数传递时,会发生值拷贝,在函数体内部对数组进行修改后,并不会影响函数体外的数据 作为强类型语言, Golang 中的数组元素必须都是相同类型,此点与 python 的 list 有...","link":"","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[{"name":"Golang","slug":"Golang","count":4,"path":"api/categories/Golang.json"}],"tags":[{"name":"Programming Language","slug":"Programming-Language","count":4,"path":"api/tags/Programming-Language.json"}],"author":{"name":"Hccc丶","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"曾经沧海难为水, 除却巫山不是云<br/>取次花丛懒回顾, 半缘修道半缘君","socials":{"github":{"link":"https://github.com/HiChen85"},"twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/logo.svg","link":"https://space.bilibili.com/512394874"}}}},"feature":true}}