{"title":"Golang Tutorial 4","uid":"ed56a0be6c67a53488e6ffd0f75904e2","slug":"Golang-Tutorial-4","date":"2021-09-05T22:06:48.000Z","updated":"2021-09-14T07:46:54.638Z","comments":true,"path":"api/articles/Golang-Tutorial-4.json","keywords":null,"cover":"/img/4.jpg","content":"<h1 id=\"Golang-Tutorial-4\"><a href=\"#Golang-Tutorial-4\" class=\"headerlink\" title=\"Golang Tutorial 4\"></a>Golang Tutorial 4</h1><h2 id=\"切片-slice\"><a href=\"#切片-slice\" class=\"headerlink\" title=\"切片(slice)\"></a>切片(slice)</h2><p>Golang 中的切片是对数组一个连续片段的引用, 因此是引用类型. 这个连续的片段可以是整个数组,也可以是由开发者指定的开始和结束索引限定的一段连续片段. 从集合的角度来看,若数组是一个元素集合,则切片就是它的一系列非空子集.</p>\n<p>既然是数组的引用,那么切片本身也具备数组的一些性质.另外,切片同时也具备一些数组不具备的特质,比如可以向切片中增加元素.</p>\n<p>切片同时提供了可以计算切片容量的函数 cap(), 如果切片是由数组创建的, 计算方法是从切片的起始元素到数组末尾的长度.</p>\n<h3 id=\"创建切片的方式\"><a href=\"#创建切片的方式\" class=\"headerlink\" title=\"创建切片的方式\"></a>创建切片的方式</h3><h4 id=\"make创建\"><a href=\"#make创建\" class=\"headerlink\" title=\"make创建\"></a>make创建</h4><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\"><span class=\"token comment\">// 创建格式: make(type, len[, cap])</span>\n<span class=\"token comment\">// 创建一个长度为 5, 容量为 10 的切片</span>\n<span class=\"token comment\">// 切片容量代表的是当切片元素达到 5 时, 继续往后最多可添加的元素个数</span>\n<span class=\"token comment\">// 当再添加五个元素后,切片容量达到最大,此时若再向其中添加元素,则需要重新构建</span>\n<span class=\"token comment\">// 新的切片.因此, 在一些结构体中,可能需要使用指针接收者来指向原始的切片数据</span>\ns1 <span class=\"token operator\">:=</span> <span class=\"token function\">make</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">10</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">// 切片的遍历</span>\n<span class=\"token keyword\">for</span> idx<span class=\"token punctuation\">,</span> value <span class=\"token operator\">:=</span> <span class=\"token keyword\">range</span> s1 <span class=\"token punctuation\">&#123;</span>\n  fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>idx<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"显式初始化\"><a href=\"#显式初始化\" class=\"headerlink\" title=\"显式初始化\"></a>显式初始化</h4><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\"><span class=\"token keyword\">var</span> sli1 <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">&#123;</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">&#125;</span>\nsli2 <span class=\"token operator\">:=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">string</span><span class=\"token punctuation\">&#123;</span><span class=\"token string\">\"zhangsan\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"lisi\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"wangwu\"</span><span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<h4 id=\"从数组中创建\"><a href=\"#从数组中创建\" class=\"headerlink\" title=\"从数组中创建\"></a>从数组中创建</h4><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">arr1 <span class=\"token operator\">:=</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">...</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">&#123;</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">&#125;</span>\nsli3 <span class=\"token operator\">:=</span> arr1<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">:</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span> <span class=\"token comment\">// 方括号中的索引是包含左边不包含右边的</span>\n<span class=\"token comment\">// sli3 的输出结果是 2 3</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"copy函数\"><a href=\"#copy函数\" class=\"headerlink\" title=\"copy函数\"></a>copy函数</h3><p>利用 copy 函数可以对一个已有的切片进行拷贝,具体语法如下</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">rst <span class=\"token operator\">:=</span> <span class=\"token function\">make</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">string</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">10</span><span class=\"token punctuation\">)</span>\ntemp <span class=\"token operator\">:=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">string</span><span class=\"token punctuation\">&#123;</span><span class=\"token string\">\"Beijing\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"London\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"Glasgow\"</span><span class=\"token punctuation\">&#125;</span>\n<span class=\"token comment\">// copy 函数会将后续参数中的元素全部复制到第一个参数的切片中</span>\n<span class=\"token comment\">// copy(dest, src) // 将 src 中的元素拷贝到 dest 中</span>\n<span class=\"token function\">copy</span><span class=\"token punctuation\">(</span>rst<span class=\"token punctuation\">,</span> temp<span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"append-函数\"><a href=\"#append-函数\" class=\"headerlink\" title=\"append 函数\"></a>append 函数</h3><p>append 函数会将0 个或者多个具有相同类型的元素追加到已有的切片中,若超出了切片的容量时, 切片会发生扩容, append 会重新分配一块<strong>新的内存区域来存放整个新的切片</strong>.<strong>此时旧的切片将保持扩容到最大容量时的数据</strong>. append 函数总是成功返回的,除非内存消耗殆尽.</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">s1 <span class=\"token operator\">:=</span> <span class=\"token function\">make</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">var</span> s2 <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">int</span>\nfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%p \\n\"</span><span class=\"token punctuation\">,</span> s2<span class=\"token punctuation\">)</span>\t<span class=\"token comment\">//打印初始的s2 地址,由于未初始化,并未分配实际的内存地址</span>\n<span class=\"token keyword\">for</span> i <span class=\"token operator\">:=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span> <span class=\"token punctuation\">&#123;</span>\t<span class=\"token comment\">// 此处设置 5 是为了测试当容量超出原始 slice 的容量时,看append 函数是否会对 slice 进行扩容并分配新的内存空间给新变量</span>\n  <span class=\"token keyword\">if</span> i <span class=\"token operator\">>=</span> <span class=\"token function\">len</span><span class=\"token punctuation\">(</span>s1<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token function\">cap</span><span class=\"token punctuation\">(</span>s1<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"长度不足,在 slice 容量内扩容\"</span><span class=\"token punctuation\">)</span>\n    s1 <span class=\"token operator\">=</span> <span class=\"token function\">append</span><span class=\"token punctuation\">(</span>s1<span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span>\n    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%p %v \\n\"</span><span class=\"token punctuation\">,</span> s1<span class=\"token punctuation\">,</span> s1<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> i <span class=\"token operator\">&lt;</span> <span class=\"token function\">len</span><span class=\"token punctuation\">(</span>s1<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"长度足够, 直接对 slice 元素赋值\"</span><span class=\"token punctuation\">)</span>\n    s1<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> i\n    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%p %v \\n\"</span><span class=\"token punctuation\">,</span> s1<span class=\"token punctuation\">,</span> s1<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">&#123;</span>\n    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"元素个数已超出原始 slice 容量, append 函数重新分配内存空间给新的 slice\"</span><span class=\"token punctuation\">)</span>\n    s2 <span class=\"token operator\">=</span> <span class=\"token function\">append</span><span class=\"token punctuation\">(</span>s1<span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span>\n    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%p %v\\n\"</span><span class=\"token punctuation\">,</span> s2<span class=\"token punctuation\">,</span> s2<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"len(s2)=%v cap(s2)=%v \\n\"</span><span class=\"token punctuation\">,</span> <span class=\"token function\">len</span><span class=\"token punctuation\">(</span>s2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">cap</span><span class=\"token punctuation\">(</span>s2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\nfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%p %v\\n\"</span><span class=\"token punctuation\">,</span> s1<span class=\"token punctuation\">,</span> s1<span class=\"token punctuation\">)</span>\nfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%p %v\\n\"</span><span class=\"token punctuation\">,</span> s2<span class=\"token punctuation\">,</span> s2<span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"slice-的扩容规则\"><a href=\"#slice-的扩容规则\" class=\"headerlink\" title=\"slice 的扩容规则\"></a>slice 的扩容规则</h3><p>根据上述代码的输出结果,最终 cap=4 的 s1 在容量不足进行扩充后,s2 容量为 8.因此扩容规则为 double 原始 slice 的容量 capacity.</p>\n<h3 id=\"new-函数和-make-函数的区别\"><a href=\"#new-函数和-make-函数的区别\" class=\"headerlink\" title=\"new 函数和 make 函数的区别\"></a>new 函数和 make 函数的区别</h3><p>new 函数会分配指定类型的指针给变量. 多用于结构体类型和数组等值类型变量, 相当于<code>&amp;T&#123;&#125;</code>,其中 T 可以是<code>[5]int</code>, <code>[6]string</code>以及 <code>&amp;Student&#123;&#125;</code>等自定义类型.</p>\n<p>new 函数创建的指针变量值为 <code>0x0</code>, 若为 silce, 则 <code>len=0, cap=0</code>. 变量指向的实际 slice 为一个<code>nil</code>.而 slice 的 nil 输出为一个<code>[]</code>.</p>\n<p>make 会初始化一个slice 变量, 并分配实际内存, 创建对应类型的初值. 在不指定 cap 的时候,cap 会与 len 相等.</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">temp1 <span class=\"token operator\">:=</span> <span class=\"token function\">new</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span>\nfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%p %v %v %v\\n\"</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">*</span>temp1<span class=\"token punctuation\">,</span> <span class=\"token operator\">*</span>temp1<span class=\"token punctuation\">,</span> <span class=\"token function\">len</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>temp1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">cap</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>temp1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\nfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>temp1 <span class=\"token operator\">==</span> <span class=\"token boolean\">nil</span><span class=\"token punctuation\">)</span>\ntemp2 <span class=\"token operator\">:=</span> <span class=\"token function\">make</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span>\nfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%p %v %v %v \\n\"</span><span class=\"token punctuation\">,</span> temp2<span class=\"token punctuation\">,</span> temp2<span class=\"token punctuation\">,</span> <span class=\"token function\">len</span><span class=\"token punctuation\">(</span>temp2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">cap</span><span class=\"token punctuation\">(</span>temp2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>可以根据上述代码自行检验结果.</p>\n","text":"Golang Tutorial 4切片(slice)Golang 中的切片是对数组一个连续片段的引用, 因此是引用类型. 这个连续的片段可以是整个数组,也可以是由开发者指定的开始和结束索引限定的一段连续片段. 从集合的角度来看,若数组是一个元素集合,则切片就是它的一系列非空子集....","link":"","photos":[],"count_time":{"symbolsCount":"2.5k","symbolsTime":"2 mins."},"categories":[{"name":"Golang","slug":"Golang","count":9,"path":"api/categories/Golang.json"}],"tags":[{"name":"Programming Language","slug":"Programming-Language","count":9,"path":"api/tags/Programming-Language.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Golang-Tutorial-4\"><span class=\"toc-text\">Golang Tutorial 4</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%88%87%E7%89%87-slice\"><span class=\"toc-text\">切片(slice)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%9B%E5%BB%BA%E5%88%87%E7%89%87%E7%9A%84%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">创建切片的方式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#make%E5%88%9B%E5%BB%BA\"><span class=\"toc-text\">make创建</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%98%BE%E5%BC%8F%E5%88%9D%E5%A7%8B%E5%8C%96\"><span class=\"toc-text\">显式初始化</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BB%8E%E6%95%B0%E7%BB%84%E4%B8%AD%E5%88%9B%E5%BB%BA\"><span class=\"toc-text\">从数组中创建</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#copy%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">copy函数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#append-%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">append 函数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#slice-%E7%9A%84%E6%89%A9%E5%AE%B9%E8%A7%84%E5%88%99\"><span class=\"toc-text\">slice 的扩容规则</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#new-%E5%87%BD%E6%95%B0%E5%92%8C-make-%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">new 函数和 make 函数的区别</span></a></li></ol></li></ol></li></ol>","author":{"name":"Hccc丶","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"曾经沧海难为水, 除却巫山不是云<br/>取次花丛懒回顾, 半缘修道半缘君","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"github":{"icon":"/svg/github.svg","link":"https://github.com/HiChen85"},"bilibili":{"icon":"/svg/logo.svg","link":"https://space.bilibili.com/512394874"}}}},"mapped":true,"prev_post":{"title":"Golang Tutorial 5","uid":"21b7afb55dd7403da1611146a47b852e","slug":"Golang-Tutorial-5","date":"2021-09-12T12:18:36.000Z","updated":"2021-09-14T07:47:08.135Z","comments":true,"path":"api/articles/Golang-Tutorial-5.json","keywords":null,"cover":"/img/5.jpg","text":"Golang Tutorila 5Map Tutorialmap 在 go语言中也是一种引用类型, 因此多使用 make 函数来创建. 基础语法格式var m map[keyType]valueType var studentId map[string]int 同 slice 一...","link":"","photos":[],"count_time":{"symbolsCount":"2.7k","symbolsTime":"2 mins."},"categories":[{"name":"Golang","slug":"Golang","count":9,"path":"api/categories/Golang.json"}],"tags":[{"name":"Programming Language","slug":"Programming-Language","count":9,"path":"api/tags/Programming-Language.json"}],"author":{"name":"Hccc丶","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"曾经沧海难为水, 除却巫山不是云<br/>取次花丛懒回顾, 半缘修道半缘君","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"github":{"icon":"/svg/github.svg","link":"https://github.com/HiChen85"},"bilibili":{"icon":"/svg/logo.svg","link":"https://space.bilibili.com/512394874"}}}}},"next_post":{"title":"Golang Tutorial 3","uid":"3983d1b06f9cc59a424cf4b8b973001f","slug":"Golang-Tutorial-3","date":"2021-09-03T07:30:17.000Z","updated":"2021-09-12T00:55:53.899Z","comments":true,"path":"api/articles/Golang-Tutorial-3.json","keywords":null,"cover":"/img/3.jpg","text":"Golang Tutorial 3数组(Array)在 golang 中,数组是值类型变量,当作为参数传递时,会发生值拷贝,在函数体内部对数组进行修改后,并不会影响函数体外的数据 作为强类型语言, Golang 中的数组元素必须都是相同类型,此点与 python 的 list 有...","link":"","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[{"name":"Golang","slug":"Golang","count":9,"path":"api/categories/Golang.json"}],"tags":[{"name":"Programming Language","slug":"Programming-Language","count":9,"path":"api/tags/Programming-Language.json"}],"author":{"name":"Hccc丶","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"曾经沧海难为水, 除却巫山不是云<br/>取次花丛懒回顾, 半缘修道半缘君","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"github":{"icon":"/svg/github.svg","link":"https://github.com/HiChen85"},"bilibili":{"icon":"/svg/logo.svg","link":"https://space.bilibili.com/512394874"}}}}}}