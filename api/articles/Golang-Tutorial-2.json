{"title":"Golang Tutorial 2","uid":"f20d4f48999b3be7c6a4f7d5c95630f9","slug":"Golang-Tutorial-2","date":"2021-09-02T22:10:10.000Z","updated":"2021-09-03T21:49:44.152Z","comments":true,"path":"api/articles/Golang-Tutorial-2.json","keywords":null,"cover":"/img/2.jpg","content":"<h1 id=\"Golang-的-String-详解\"><a href=\"#Golang-的-String-详解\" class=\"headerlink\" title=\"Golang 的 String 详解\"></a>Golang 的 String 详解</h1><p>本章介绍 Go 语言中 string 相关的内容. 包括字符串创建, 修改, 遍历和转换等操作</p>\n<span id=\"more\"></span>\n\n<h3 id=\"Unicode-in-Go\"><a href=\"#Unicode-in-Go\" class=\"headerlink\" title=\"Unicode in Go\"></a>Unicode in Go</h3><p>在 go 中支持 Unicode(UTF-8), 因此字符也称为 Unicode 码点或者runes, 在内存中用 int32 表示.但具体每隔字符占据多少字节是不一样的.一个中文在 go 中占据 3 个字节.</p>\n<h3 id=\"rune-类型与-byte-类型\"><a href=\"#rune-类型与-byte-类型\" class=\"headerlink\" title=\"rune 类型与 byte 类型\"></a>rune 类型与 byte 类型</h3><p>rune 类型在 go 语言底层实现是一个 int32类型, 它仅仅是一个 int32 的别名. byte 类型底层实现是一个 uint8类型.它也是一个别名</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">type byte &#x3D; uint8\ntype rune &#x3D; int32</code></pre>\n\n<h3 id=\"零值\"><a href=\"#零值\" class=\"headerlink\" title=\"零值\"></a>零值</h3><p>String 类型的 0 值是一个长度为 0 的字符串<code>&quot;&quot;</code>.因为 go 中 string 是值类型,所以 0 值不是 nil,无法与 nil 进行比较.</p>\n<h3 id=\"字符串比较\"><a href=\"#字符串比较\" class=\"headerlink\" title=\"字符串比较\"></a>字符串比较</h3><p>一般的字符串比较, 实际是通过在内存中比较字节来实现的. 比如<code>&gt;=, &lt;= , == , !=</code>.</p>\n<h3 id=\"字符串单个字符的获取\"><a href=\"#字符串单个字符的获取\" class=\"headerlink\" title=\"字符串单个字符的获取\"></a>字符串单个字符的获取</h3><p>字符串单个字符的获取可以通过索引的方式[]来获取,但需要注意的是,在中文字符中,由于一个字符占据三个字节,所以一定要知道在包含中文的字符中,两个字符之间的索引间距不一定是 1,可能是 3</p>\n<h3 id=\"使用-range-遍历字符串\"><a href=\"#使用-range-遍历字符串\" class=\"headerlink\" title=\"使用 range 遍历字符串\"></a>使用 range 遍历字符串</h3><p>在使用 range 遍历字符串时,以字符为单位进行遍历,也就是说,在返回的 i, 和 v 中,i 的值并不都是规律的</p>\n<h3 id=\"字符串拼接\"><a href=\"#字符串拼接\" class=\"headerlink\" title=\"字符串拼接\"></a>字符串拼接</h3><h4 id=\"拼接\"><a href=\"#拼接\" class=\"headerlink\" title=\"+ 拼接\"></a>+ 拼接</h4><p>使用这种拼接方式的缺点在于: 字符串一旦定义就不可更改,有时为了获取最终字符会产生很多的无用字符串,为程序带来 gc 的压力,性能相对较差.</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">str1 :&#x3D; &quot;hello&quot;\nstr2 :&#x3D; &quot;world&quot;\nstr3 :&#x3D; str1 + str22</code></pre>\n\n<h4 id=\"使用-fmt-Sprintf\"><a href=\"#使用-fmt-Sprintf\" class=\"headerlink\" title=\"使用 fmt.Sprintf()\"></a>使用 fmt.Sprintf()</h4><p>此函数内部逻辑较为复杂,判断条件众多, 使用[]byte 实现,性能一般</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">fmt.Sprintf(&quot;%d %s&quot;, 2021, &quot;年&quot;)</code></pre>\n\n<h4 id=\"strings-Join\"><a href=\"#strings-Join\" class=\"headerlink\" title=\"strings.Join()\"></a>strings.Join()</h4><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">strings.Join([]string&#123;&quot;你好&quot;, &quot;golang&quot;&#125;, &quot;-&quot;)</code></pre>\n\n<p>此函数会根据字符串切片的内容,计算一个拼接之后的总长度,然后申请对应内存大小的内存区域,一个个的填入拼接后的字符串.</p>\n<p>在已有一个字符串切片的情况下,这个效率很搞,但是若本身并没有待拼接的字符串时,创建该数组的代价很大.</p>\n<p>Join 函数在拼接字符串时,会在每个切片元素之间插入一个空字符串<code>&quot;&quot;</code>, 然后根据第二个参数指定的字符串进行替换.</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">var arrKeyValue &#x3D; [5]string&#123;2: &quot;Chris&quot;, 4: &quot;Ron&quot;&#125;\nfmt.Println(strings.Join(arrKeyValue[:], &quot;,&quot;))</code></pre>\n\n<p>上述代码利用指定数组元素索引的方式初始化了数组,然后利用切片特性将数组转化为切片.输出结果为</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">,,Chris,,Ron \n&#x2F;&#x2F; Ron 前面一个逗号是 Join 函数添加的,因为要在两个字符之间添加一个空字符串\n&#x2F;&#x2F; Chris 前的两个逗号和后面的第一个逗号是原本初始化数组时默认给定的字符串 0 值\n&#x2F;&#x2F; 在Join 函数内统一将 &quot;&quot; 替换为了指定的字符串</code></pre>\n\n<h4 id=\"bytes-Buffer-与-strings-Builder\"><a href=\"#bytes-Buffer-与-strings-Builder\" class=\"headerlink\" title=\"bytes.Buffer()与 strings.Builder()\"></a>bytes.Buffer()与 strings.Builder()</h4><p>在介绍 bytes.Buffer 和 strings.Builder()之前,先讨论一下 Golang 中的 Pointer 类型, 以及通过 Pointer 对同一块内存数据进行类型转换的方式.</p>\n<h4 id=\"unsafe-Pointer\"><a href=\"#unsafe-Pointer\" class=\"headerlink\" title=\"unsafe.Pointer\"></a>unsafe.Pointer</h4><p>unsafe.Pointer 代表任意一种类型的指针, 它有四种特殊操作:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">A pointer value of any type can be converted to a Pointer\nA Pointer instance can be converted to a pointer value of any type.\nA uintptr can be converted to a Pointer.\nA Pointer can be converted to a uintptr.</code></pre>\n\n<h4 id=\"类型转换模式\"><a href=\"#类型转换模式\" class=\"headerlink\" title=\"类型转换模式\"></a>类型转换模式</h4><p>上述的四个操作意思可以简单对应于如下形式</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">*T1 &#x3D;&gt; Pointer &#x3D;&gt; *T2</code></pre>\n\n<p>借助Pointer,可以实现一个指针类型的变量到另一个指针类型变量的转换.在这种转换模式中需要保证的是转换后指针类型的T2 的内存 <code>&lt;= </code>T1 的内存. 而且,转换前后两个类型的变量公用同一个内存数据.</p>\n<h4 id=\"string-和-byte-转换\"><a href=\"#string-和-byte-转换\" class=\"headerlink\" title=\"string 和 []byte 转换\"></a>string 和 []byte 转换</h4><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">var b &#x3D; []byte&#123;&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;&#125; &#x2F;&#x2F; 注意这里是单引号\n&#x2F;&#x2F; 这个步骤就将一个 byte 的 slice 转换成了一个 string 变量,且二者公用同一个快内存数据.\n&#x2F;&#x2F; 一旦 b 被更改,则 s 随之更改\n&#x2F;&#x2F; 因为 string 本身是一个不可变的,所以不能对 s 做任何的修改操作.\ns :&#x3D; *(*string)(unsafe.Pointer(&amp;b))\nfmt.Println(&quot;b: &quot;, b)\nfmt.Println(&quot;s: &quot;, s)\n&#x2F;&#x2F; 结果相同\n&#x2F;&#x2F; 现在修改 b 中的数据\nb[3] &#x3D; &quot;z&quot;\nfmt.Println(&quot;b: &quot;, b)\nfmt.Println(&quot;s: &quot;, s)\n&#x2F;&#x2F; b 与 s 都发生了变化\n&#x2F;&#x2F; 给 s 赋一个新的值, b 不会发生变化,因为 s 是 string 类型,赋新值会创建一个新的 string实例\ns &#x3D; &quot;ABCD&quot;\nfmt.Println(&quot;b: &quot;, b) &#x2F;&#x2F; abcz\nfmt.Println(&quot;s: &quot;, s) &#x2F;&#x2F; ABCD</code></pre>\n\n<h4 id=\"bytes-Buffer和-strings-Builder-的用法\"><a href=\"#bytes-Buffer和-strings-Builder-的用法\" class=\"headerlink\" title=\"bytes.Buffer和 strings.Builder 的用法\"></a>bytes.Buffer和 strings.Builder 的用法</h4><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">&#x2F;&#x2F; bytes.Buffer\nvar buffer bytes.Buffer\nbuffer.WriteString(&quot;hello&quot;)\nbuffer.WriteString(&quot;,&quot;)\nbuffer.WriteString(&quot;中国&quot;)\nbuffer.WriteString(&quot;!!!&quot;)\nfmt.Println(buffer.String())\n\n&#x2F;&#x2F; strings\nvar builder strings.Builder\nbuilder.WriteString(&quot;ABCD&quot;)\nbuilder.WriteString(&quot;-&quot;)\nbuilder.WriteString(&quot;EFGH&quot;)\nfmt.Println(builder.String())</code></pre>\n\n<h4 id=\"strings-Builder-底层实现\"><a href=\"#strings-Builder-底层实现\" class=\"headerlink\" title=\"strings.Builder()底层实现\"></a>strings.Builder()底层实现</h4><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">func (b *Builder) String() string &#123;\n\treturn *(*string)(unsafe.Pointer(&amp;b.buf))\n&#125;</code></pre>\n\n<p>由于是在同一块内存上操作,性能比 bytes.Buffer有所提升</p>\n<h3 id=\"byte-rune-与-string-的相互转化\"><a href=\"#byte-rune-与-string-的相互转化\" class=\"headerlink\" title=\"[]byte, []rune 与 string 的相互转化\"></a>[]byte, []rune 与 string 的相互转化</h3><h4 id=\"byte-与-string-的相互转化\"><a href=\"#byte-与-string-的相互转化\" class=\"headerlink\" title=\"[]byte 与 string 的相互转化\"></a>[]byte 与 string 的相互转化</h4><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">&#x2F;&#x2F; []byte 转为 string\n&#x2F;&#x2F; 第一种借助 unsafe.Pointer 方式转化\nvar bStr &#x3D; []byte&#123;&#39;a&#39;, &#39;b&#39;, &#39;c&#39;&#125;\ns1 :&#x3D; *(*string)(unsafe.Pointer(&amp;bStr))\n&#x2F;&#x2F; 第二种直接用类型转换强转\ns2 &#x3D; string(bStr)\n\n&#x2F;&#x2F; string 转为[]byte\nstr :&#x3D; &quot;这是 string&quot;\nbStr2 :&#x3D; []byte(str)\n&#x2F;&#x2F; 这里的转换会创建一块新内存来对 bStr2 赋值,与 str 独立\n&#x2F;&#x2F; 对 bStr3 的操作,不会影响原本字符串的数据\ns2 :&#x3D; &quot;hello Golang&quot;\nbStr3 :&#x3D; []byte(s2)\nfmt.Println(bStr3)\nbStr3[11] &#x3D; 104\nfmt.Println(s2)\nfmt.Println(string(bStr3))</code></pre>\n\n<p>从上述代码可以得到的结论: 直接使用类型转换时,会产生对原始数据的拷贝,因此对新数据的修改([]byte的修改,因为 string 是不可修改的)不会影响原本的字符串数据.</p>\n<p>换句话说,也正是为了保证 string 不可变的这种一致性,所以才会在进行类型转换时产生数据的拷贝</p>\n<h4 id=\"rune-与-string-的转化\"><a href=\"#rune-与-string-的转化\" class=\"headerlink\" title=\"[]rune 与 string 的转化\"></a>[]rune 与 string 的转化</h4><p>​    []rune 与 string 的转化与[]byte 类似,只需要将 byte 换成 rune 即可</p>\n","feature":true,"text":"Golang 的 String 详解本章介绍 Go 语言中 string 相关的内容. 包括字符串创建, 修改, 遍历和转换等操作 Unicode in Go在 go 中支持 Unicode(UTF-8), 因此字符也称为 Unicode 码点或者runes, 在内存中用 int...","link":"","photos":[],"count_time":{"symbolsCount":"4.3k","symbolsTime":"4 mins."},"categories":[{"name":"Golang","slug":"Golang","count":4,"path":"api/categories/Golang.json"}],"tags":[{"name":"Programming Language","slug":"Programming-Language","count":4,"path":"api/tags/Programming-Language.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Golang-%E7%9A%84-String-%E8%AF%A6%E8%A7%A3\"><span class=\"toc-text\">Golang 的 String 详解</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Unicode-in-Go\"><span class=\"toc-text\">Unicode in Go</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#rune-%E7%B1%BB%E5%9E%8B%E4%B8%8E-byte-%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">rune 类型与 byte 类型</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%9B%B6%E5%80%BC\"><span class=\"toc-text\">零值</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83\"><span class=\"toc-text\">字符串比较</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8D%95%E4%B8%AA%E5%AD%97%E7%AC%A6%E7%9A%84%E8%8E%B7%E5%8F%96\"><span class=\"toc-text\">字符串单个字符的获取</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8-range-%E9%81%8D%E5%8E%86%E5%AD%97%E7%AC%A6%E4%B8%B2\"><span class=\"toc-text\">使用 range 遍历字符串</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5\"><span class=\"toc-text\">字符串拼接</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%8B%BC%E6%8E%A5\"><span class=\"toc-text\">+ 拼接</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8-fmt-Sprintf\"><span class=\"toc-text\">使用 fmt.Sprintf()</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#strings-Join\"><span class=\"toc-text\">strings.Join()</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#bytes-Buffer-%E4%B8%8E-strings-Builder\"><span class=\"toc-text\">bytes.Buffer()与 strings.Builder()</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#unsafe-Pointer\"><span class=\"toc-text\">unsafe.Pointer</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">类型转换模式</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#string-%E5%92%8C-byte-%E8%BD%AC%E6%8D%A2\"><span class=\"toc-text\">string 和 []byte 转换</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#bytes-Buffer%E5%92%8C-strings-Builder-%E7%9A%84%E7%94%A8%E6%B3%95\"><span class=\"toc-text\">bytes.Buffer和 strings.Builder 的用法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#strings-Builder-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">strings.Builder()底层实现</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#byte-rune-%E4%B8%8E-string-%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E5%8C%96\"><span class=\"toc-text\">[]byte, []rune 与 string 的相互转化</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#byte-%E4%B8%8E-string-%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E5%8C%96\"><span class=\"toc-text\">[]byte 与 string 的相互转化</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#rune-%E4%B8%8E-string-%E7%9A%84%E8%BD%AC%E5%8C%96\"><span class=\"toc-text\">[]rune 与 string 的转化</span></a></li></ol></li></ol></li></ol></li></ol>","author":{"name":"Hccc丶","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"曾经沧海难为水, 除却巫山不是云<br/>取次花丛懒回顾, 半缘修道半缘君","socials":{"github":{"link":"https://github.com/HiChen85"},"twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/logo.svg","link":"https://space.bilibili.com/512394874"}}}},"mapped":true,"prev_post":{"title":"Golang Tutorial 3","uid":"3983d1b06f9cc59a424cf4b8b973001f","slug":"Golang-Tutorial-3","date":"2021-09-03T07:30:17.000Z","updated":"2021-09-12T00:55:53.899Z","comments":true,"path":"api/articles/Golang-Tutorial-3.json","keywords":null,"cover":"/img/3.jpg","text":"Golang Tutorial 3数组(Array)在 golang 中,数组是值类型变量,当作为参数传递时,会发生值拷贝,在函数体内部对数组进行修改后,并不会影响函数体外的数据 作为强类型语言, Golang 中的数组元素必须都是相同类型,此点与 python 的 list 有...","link":"","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[{"name":"Golang","slug":"Golang","count":4,"path":"api/categories/Golang.json"}],"tags":[{"name":"Programming Language","slug":"Programming-Language","count":4,"path":"api/tags/Programming-Language.json"}],"author":{"name":"Hccc丶","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"曾经沧海难为水, 除却巫山不是云<br/>取次花丛懒回顾, 半缘修道半缘君","socials":{"github":{"link":"https://github.com/HiChen85"},"twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/logo.svg","link":"https://space.bilibili.com/512394874"}}}},"feature":true},"next_post":{}}