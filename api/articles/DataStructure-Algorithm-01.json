{"title":"DataStructure 01","uid":"2e282140550dbaba095df242e62ffa5e","slug":"DataStructure-Algorithm-01","date":"2021-09-18T16:42:03.000Z","updated":"2021-09-20T08:27:59.773Z","comments":true,"path":"api/articles/DataStructure-Algorithm-01.json","keywords":null,"cover":"/img/2.jpg","content":"<h1 id=\"DataStructure-01\"><a href=\"#DataStructure-01\" class=\"headerlink\" title=\"DataStructure 01\"></a>DataStructure 01</h1><h2 id=\"单链表\"><a href=\"#单链表\" class=\"headerlink\" title=\"单链表\"></a>单链表</h2><p>单链表是线性表的一种链式存储结构, 具有单向性,只能从前向后遍历.</p>\n<h4 id=\"单链表的特性\"><a href=\"#单链表的特性\" class=\"headerlink\" title=\"单链表的特性:\"></a>单链表的特性:</h4><ol>\n<li>单链表的尾结点的 next 域为空</li>\n<li>做添加(在尾结点添加), 插入(任意位置), 删除(任意位置)比较容易, 查询遍历来说比较耗时.</li>\n</ol>\n<h4 id=\"单链表的golang-实现\"><a href=\"#单链表的golang-实现\" class=\"headerlink\" title=\"单链表的golang 实现\"></a>单链表的golang 实现</h4><p>在用 go 语言实现单链表时, 为了方便在尾部插入数据, 所以在链表结构中定义了一个尾指针.</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\"><span class=\"token keyword\">type</span> node <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">&#123;</span>\n  value <span class=\"token keyword\">interface</span><span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span>\n  next <span class=\"token operator\">*</span>node\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">*</span>node<span class=\"token punctuation\">)</span> <span class=\"token function\">Value</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">interface</span><span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">return</span> n<span class=\"token punctuation\">.</span>value\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">*</span>node<span class=\"token punctuation\">)</span> <span class=\"token function\">Next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span>node <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">return</span> n<span class=\"token punctuation\">.</span>next\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">type</span> SingleLinkedList <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">&#123;</span>\n  length <span class=\"token builtin\">int</span>\n  head <span class=\"token operator\">*</span>node\n  tail <span class=\"token operator\">*</span>node\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">NewSingleLinkedList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span>SingleLinkedList <span class=\"token punctuation\">&#123;</span>\n  sll <span class=\"token operator\">:=</span> <span class=\"token function\">new</span><span class=\"token punctuation\">(</span>SingleLinkedList<span class=\"token punctuation\">)</span>\n  sll<span class=\"token punctuation\">.</span>head <span class=\"token operator\">=</span> <span class=\"token boolean\">nil</span>\n  sll<span class=\"token punctuation\">.</span>tail <span class=\"token operator\">=</span> <span class=\"token boolean\">nil</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>s <span class=\"token operator\">*</span>SingleLinkedList<span class=\"token punctuation\">)</span> <span class=\"token function\">Head</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span>node <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">return</span> s<span class=\"token punctuation\">.</span>head\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>s <span class=\"token operator\">*</span>SingleLinkedList<span class=\"token punctuation\">)</span> <span class=\"token function\">Len</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token builtin\">int</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">return</span> s<span class=\"token punctuation\">.</span>length\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h5 id=\"单链表添加元素\"><a href=\"#单链表添加元素\" class=\"headerlink\" title=\"单链表添加元素\"></a>单链表添加元素</h5><p>在添加元素时, 需要注意的是, 当创建好数据节点后,要对链表进行判断, 看头结点指针是否为空, 则该数据节点为头结点,否则, 就应该将该节点添加在尾结点上.</p>\n<p>针对在尾结点上添加节点的处理, 需要注意: 首先,当前的尾结点仍然是一个数据节点,而根据单链表的特性,尾结点的 next 域为空,所以要让新的节点挂载到尾结点的 next 上.</p>\n<p>不论是头结点为空还是不为空,添加完节点后, 都要更新尾指针. 同时链表长度增加</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>s <span class=\"token operator\">*</span>SingleLinkedList<span class=\"token punctuation\">)</span> <span class=\"token function\">Append</span><span class=\"token punctuation\">(</span>value <span class=\"token keyword\">interface</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n  e <span class=\"token operator\">:=</span> <span class=\"token function\">new</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">)</span>\n  e<span class=\"token punctuation\">.</span>value <span class=\"token operator\">=</span> value\n  e<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> <span class=\"token boolean\">nil</span>\n  \n  <span class=\"token keyword\">if</span> s<span class=\"token punctuation\">.</span>head <span class=\"token operator\">==</span> <span class=\"token boolean\">nil</span> <span class=\"token punctuation\">&#123;</span>\n    s<span class=\"token punctuation\">.</span>head <span class=\"token operator\">=</span> e\n  <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">&#123;</span>\n    s<span class=\"token punctuation\">.</span>tail<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> e\n  <span class=\"token punctuation\">&#125;</span>\n  <span class=\"token comment\">// 更新尾指针, 从第一个节点开始,当创建好了节点后,一定得是要让尾指针指向最后一个节点.</span>\n  s<span class=\"token punctuation\">.</span>tail <span class=\"token operator\">=</span> e\n  s<span class=\"token punctuation\">.</span>length<span class=\"token operator\">++</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"单链表的插入\"><a href=\"#单链表的插入\" class=\"headerlink\" title=\"单链表的插入\"></a>单链表的插入</h4><p>想要比较高效的操作单链表, 就一定要使用双指针,因为在单链表中, 如果仅使用单指针遍历节点,则无法知道节点的前驱节点,在插入和删除时, 很难操作. 因此使用双指针(一快一慢)可以方便的记录链表节点的前驱节点</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>s <span class=\"token operator\">*</span>SingleLinkedList<span class=\"token punctuation\">)</span> <span class=\"token function\">Insert</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">,</span> at <span class=\"token keyword\">interface</span><span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n  e <span class=\"token operator\">:=</span> <span class=\"token function\">new</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">)</span>\n  e<span class=\"token punctuation\">.</span>value <span class=\"token operator\">=</span> value\n  e<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> <span class=\"token boolean\">nil</span>\n  <span class=\"token keyword\">if</span> s<span class=\"token punctuation\">.</span>head<span class=\"token punctuation\">.</span>value <span class=\"token operator\">==</span> at <span class=\"token punctuation\">&#123;</span>\n    e<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> s<span class=\"token punctuation\">.</span>head\n    s<span class=\"token punctuation\">.</span>head <span class=\"token operator\">=</span> e\n    s<span class=\"token punctuation\">.</span>length<span class=\"token operator\">++</span>\n  <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">for</span> prev<span class=\"token punctuation\">,</span> flag <span class=\"token operator\">:=</span> s<span class=\"token punctuation\">.</span>head<span class=\"token punctuation\">,</span> s<span class=\"token punctuation\">.</span>head<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span> flag <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">&#123;</span>\n      <span class=\"token keyword\">if</span> flag<span class=\"token punctuation\">.</span>value <span class=\"token operator\">!=</span> at <span class=\"token punctuation\">&#123;</span>\n        prev <span class=\"token operator\">=</span> prev<span class=\"token punctuation\">.</span>next\n        flag <span class=\"token operator\">=</span> flag<span class=\"token punctuation\">.</span>next\n      <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">&#123;</span>\n        prev<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> e\n        e<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> flag\n        s<span class=\"token punctuation\">.</span>length<span class=\"token operator\">++</span>\n        <span class=\"token comment\">// return 是为了保证只在第一个搜索到的位置插入</span>\n        <span class=\"token keyword\">return</span>\n      <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span>\n  <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"单链表的删除\"><a href=\"#单链表的删除\" class=\"headerlink\" title=\"单链表的删除\"></a>单链表的删除</h4><p>链表的删除操作十分简单,首先需要遍历链表,查找到需要删除的节点, 利用双指针, 就可以轻易的将该节点删除.</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>s <span class=\"token operator\">*</span>SingleLinkedList<span class=\"token punctuation\">)</span> <span class=\"token function\">Delete</span><span class=\"token punctuation\">(</span>value <span class=\"token keyword\">interface</span><span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">if</span> s<span class=\"token punctuation\">.</span>head<span class=\"token punctuation\">.</span>value <span class=\"token operator\">==</span> value <span class=\"token punctuation\">&#123;</span>\n    s<span class=\"token punctuation\">.</span>head <span class=\"token operator\">=</span> s<span class=\"token punctuation\">.</span>head<span class=\"token punctuation\">.</span>next\n    s<span class=\"token punctuation\">.</span>length<span class=\"token operator\">--</span>\n  <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">for</span> prev<span class=\"token punctuation\">,</span> flag <span class=\"token operator\">:=</span> s<span class=\"token punctuation\">.</span>head<span class=\"token punctuation\">,</span> s<span class=\"token punctuation\">.</span>head<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span> flag <span class=\"token operator\">!=</span> <span class=\"token boolean\">nil</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">&#123;</span>\n      <span class=\"token keyword\">if</span> flag<span class=\"token punctuation\">.</span>value <span class=\"token operator\">!=</span> value <span class=\"token punctuation\">&#123;</span>\n        prev <span class=\"token operator\">=</span> prev<span class=\"token punctuation\">.</span>next\n        flag <span class=\"token operator\">=</span> flag<span class=\"token punctuation\">.</span>next\n      <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token comment\">// 让前驱节点的 next 直接指向被删除节点的后继节点</span>\n        prev<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> flag<span class=\"token punctuation\">.</span>next\n        s<span class=\"token punctuation\">.</span>length<span class=\"token operator\">--</span>\n      <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span>\n  <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<h2 id=\"双向链表\"><a href=\"#双向链表\" class=\"headerlink\" title=\"双向链表\"></a>双向链表</h2><p>双向链表指的是带有前驱和后继指针域的链表, 每个节点都可以访问其前驱结点和后继结点.</p>\n<p>关于双链表的实现<a href=\"https://github.com/HiChen85/DS_Golang/blob/master/doubleLinkedList/doubleLinkedList.go\">请看这里</a>.</p>\n","feature":true,"text":"DataStructure 01单链表单链表是线性表的一种链式存储结构, 具有单向性,只能从前向后遍历. 单链表的特性: 单链表的尾结点的 next 域为空 做添加(在尾结点添加), 插入(任意位置), 删除(任意位置)比较容易, 查询遍历来说比较耗时. 单链表的golang 实...","link":"","photos":[],"count_time":{"symbolsCount":"2.5k","symbolsTime":"2 mins."},"categories":[{"name":"DataStructure","slug":"DataStructure","count":2,"path":"api/categories/DataStructure.json"}],"tags":[{"name":"DataStructure","slug":"DataStructure","count":2,"path":"api/tags/DataStructure.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#DataStructure-01\"><span class=\"toc-text\">DataStructure 01</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8D%95%E9%93%BE%E8%A1%A8\"><span class=\"toc-text\">单链表</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E7%89%B9%E6%80%A7\"><span class=\"toc-text\">单链表的特性:</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84golang-%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">单链表的golang 实现</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%8D%95%E9%93%BE%E8%A1%A8%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0\"><span class=\"toc-text\">单链表添加元素</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5\"><span class=\"toc-text\">单链表的插入</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%A0%E9%99%A4\"><span class=\"toc-text\">单链表的删除</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8\"><span class=\"toc-text\">双向链表</span></a></li></ol></li></ol>","author":{"name":"Hccc丶","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"曾经沧海难为水, 除却巫山不是云<br/>取次花丛懒回顾, 半缘修道半缘君","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"github":{"icon":"/svg/github.svg","link":"https://github.com/HiChen85"},"bilibili":{"icon":"/svg/logo.svg","link":"https://space.bilibili.com/512394874"}}}},"mapped":true,"prev_post":{"title":"DataStructure&Algorithm-02","uid":"90b930c19317609fdd990e20fdd0d904","slug":"DataStructure-Algorithm-02","date":"2021-09-22T06:30:43.000Z","updated":"2021-09-24T04:32:36.602Z","comments":true,"path":"api/articles/DataStructure-Algorithm-02.json","keywords":null,"cover":"/img/6.jpg","text":"数据结构与算法 02分而治之(Divide &amp; Conquer) 思想分而治之是一种递归式解决问题的方法. 涉及到递归的问题通常都有两个条件 确定一个基线条件, 或者称为递归结束的条件 确定递归条件. 在分而治之的思想中, 这一步需要缩小原有问题的规模. 提示:, 在编写...","link":"","photos":[],"count_time":{"symbolsCount":"3.2k","symbolsTime":"3 mins."},"categories":[{"name":"DataStructure","slug":"DataStructure","count":2,"path":"api/categories/DataStructure.json"}],"tags":[{"name":"DataStructure","slug":"DataStructure","count":2,"path":"api/tags/DataStructure.json"}],"author":{"name":"Hccc丶","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"曾经沧海难为水, 除却巫山不是云<br/>取次花丛懒回顾, 半缘修道半缘君","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"github":{"icon":"/svg/github.svg","link":"https://github.com/HiChen85"},"bilibili":{"icon":"/svg/logo.svg","link":"https://space.bilibili.com/512394874"}}}},"feature":true},"next_post":{"title":"Golang Tutorial 9","uid":"b9ad58d220db9597427a33bc2b1eea6a","slug":"Golang-Tutorial-9","date":"2021-09-15T09:37:40.000Z","updated":"2021-09-16T07:05:29.094Z","comments":true,"path":"api/articles/Golang-Tutorial-9.json","keywords":null,"cover":"/img/5.jpg","text":"Golang Tutorial 9 Function函数的可变参数在 Go 语言中, 函数可以指定一个不定长参数来接收多个同类型参数. 但是这个参数需要放在其他固定参数的最后. 本质上这个可变参数的实现是通过 slice. 所以在接收参数后也应当以切片对待 可变参数的定义func...","link":"","photos":[],"count_time":{"symbolsCount":"4.7k","symbolsTime":"4 mins."},"categories":[{"name":"Golang","slug":"Golang","count":9,"path":"api/categories/Golang.json"}],"tags":[{"name":"Programming Language","slug":"Programming-Language","count":9,"path":"api/tags/Programming-Language.json"}],"author":{"name":"Hccc丶","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"曾经沧海难为水, 除却巫山不是云<br/>取次花丛懒回顾, 半缘修道半缘君","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"github":{"icon":"/svg/github.svg","link":"https://github.com/HiChen85"},"bilibili":{"icon":"/svg/logo.svg","link":"https://space.bilibili.com/512394874"}}}},"feature":true}}