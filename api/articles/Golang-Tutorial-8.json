{"title":"Golang Tutorial 8","uid":"b7b9075ba8f3fce9f65889bb535dd257","slug":"Golang-Tutorial-8","date":"2021-09-14T10:10:28.000Z","updated":"2021-09-15T09:37:14.838Z","comments":true,"path":"api/articles/Golang-Tutorial-8.json","keywords":null,"cover":"/img/8.jpg","content":"<h1 id=\"Golang-Tutorial-8\"><a href=\"#Golang-Tutorial-8\" class=\"headerlink\" title=\"Golang Tutorial 8\"></a>Golang Tutorial 8</h1><h2 id=\"类型的-String-方法和格式化描述符\"><a href=\"#类型的-String-方法和格式化描述符\" class=\"headerlink\" title=\"类型的 String 方法和格式化描述符\"></a>类型的 String 方法和格式化描述符</h2><h3 id=\"String-方法\"><a href=\"#String-方法\" class=\"headerlink\" title=\"String()方法\"></a>String()方法</h3><p>当定义了一个具有很多方法的类型时, 常常也会实现一个 String()方法来定制类型的字符串形式的输出. 如果一个类型定义了 String()方法,那么它会被 fmt.Printf()当成是默认输出. 等同于使用%v 产生的输出格式. fmt.Println 和 fmt.Print 也会使用这个 String()方法.</p>\n<p>换句话说,当想要为一个类型定制一个可以由 %v 形式输出的字符串. 就得实现 String 方法</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\"><span class=\"token keyword\">type</span> Dog <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">&#123;</span>\n  name <span class=\"token builtin\">string</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">NewDog</span><span class=\"token punctuation\">(</span>name <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span>Dog <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token operator\">&amp;</span>Dog<span class=\"token punctuation\">&#123;</span>name<span class=\"token punctuation\">:</span> name<span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token comment\">// 定义 String 方法, 当使用 fmt.Println() 直接打印 Dog 类型的变量时, 会根据 String 方法</span>\n<span class=\"token comment\">// 的返回值返回相应的字符串.</span>\n<span class=\"token comment\">// 需要注意, String 是方法,需要一个接收者</span>\n<span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>d <span class=\"token operator\">*</span>Dog<span class=\"token punctuation\">)</span> <span class=\"token function\">String</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token builtin\">string</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token comment\">// 这里定义直接返回类型名</span>\n  <span class=\"token keyword\">return</span> <span class=\"token string\">\"Dog\"</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>当使用指针类型实现了 String 方法后,如果在实际传参时给一个值类型,则 fmt.Println 等方法不会调用 String 方法.而是用默认的输出格式</strong>.</p>\n<p>因此为了规范统一,当使用指针类型接收者时, 就创建结构体指针,如果是值类型接收者,就创建结构体的值</p>\n<h2 id=\"使用值接收者和指针接收者实现接口的差异\"><a href=\"#使用值接收者和指针接收者实现接口的差异\" class=\"headerlink\" title=\"使用值接收者和指针接收者实现接口的差异\"></a>使用值接收者和指针接收者实现接口的差异</h2><p>当定义好了接口之后, 需要类型去具体实现接口中的方法. 方法的接收者类型在之前已经学过, 分为值类型和指针类型. 二者在接口类型的变量上表现有哪些差异呢?</p>\n<h4 id=\"值类型接收者实现接口\"><a href=\"#值类型接收者实现接口\" class=\"headerlink\" title=\"值类型接收者实现接口\"></a>值类型接收者实现接口</h4><p>当使用值类型接收者实现了接口中的所有方法后, 可以让<strong>接口变量</strong>去直接接收该类型的普通变量或者是指针变量.</p>\n<h4 id=\"指针类型接收者实现接口\"><a href=\"#指针类型接收者实现接口\" class=\"headerlink\" title=\"指针类型接收者实现接口\"></a>指针类型接收者实现接口</h4><p>当使用了指针接收者实现了接口中的方法, 那么使用接口变量再去接收改类型的普通变量时,编译无法通过,会告知你必须<strong>接口变量</strong>只能接收指针类型的接收者.</p>\n<p><strong>重点:</strong></p>\n<p><strong>为保证作为 gopher 的职业生涯: 请始终牢记, interface 在 go 中也是一种类型</strong></p>\n<h3 id=\"空接口\"><a href=\"#空接口\" class=\"headerlink\" title=\"空接口:\"></a>空接口:</h3><p>空接口是指没有定义任何方法的接口。因此可以认为是任何类型都实现了空接口。</p>\n<p>所以空接口变量可以接收任意类型的变量.</p>\n<h2 id=\"类型断言\"><a href=\"#类型断言\" class=\"headerlink\" title=\"类型断言\"></a>类型断言</h2><p>检测在程序运行时, 接口变量中实际存储的变量类型是什么.</p>\n<p>断言语法:<code>v, ok := iVal.(T)</code>. <code>i</code>前缀表示此变量是一个接口变量, 这个语法和 map 类型判断是否含有特定 key 的语法类似, 当 iVal 中实际存储的变量类型为 T 时, 则 v 就是接口变量iVal 转换为类型 T 的值, 且有 ok=true. 否则就是类型 T 的 0 值, 且 ok=false.</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\"><span class=\"token keyword\">if</span> v<span class=\"token punctuation\">,</span> ok <span class=\"token operator\">:=</span> iVal<span class=\"token punctuation\">.</span><span class=\"token punctuation\">(</span>T<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> ok <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token function\">Process</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">return</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"使用-type-swithc-来进行多值类型判断\"><a href=\"#使用-type-swithc-来进行多值类型判断\" class=\"headerlink\" title=\"使用 type-swithc 来进行多值类型判断\"></a>使用 type-swithc 来进行多值类型判断</h4><p>在使用 switch 做类型断言时, 括号内一定是使用 type 关键字</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\"><span class=\"token keyword\">switch</span> t <span class=\"token operator\">:=</span> iVar<span class=\"token punctuation\">.</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">type</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">case</span> <span class=\"token operator\">*</span>Square<span class=\"token punctuation\">:</span>\n  \tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">case</span> <span class=\"token operator\">*</span>Circle<span class=\"token punctuation\">:</span>\n  \tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">case</span> <span class=\"token operator\">*</span>Rectangle<span class=\"token punctuation\">:</span>\n  \tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">case</span> <span class=\"token keyword\">default</span><span class=\"token punctuation\">:</span>\n  \tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>iVar 是一个接口类型变量, 当程序运行时会接受一个具体的类型传入, 此段程序就用于判断该接口变量实际存储的具体是什么类型, 并拿到该类型对应的值 t.</p>\n<p>若指向单纯的判断接口中实际接收的类型, 可以省略 t.代码如下</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\"><span class=\"token keyword\">switch</span> iVar<span class=\"token punctuation\">.</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">type</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">case</span> <span class=\"token operator\">*</span>Square<span class=\"token punctuation\">:</span>\n  \tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">case</span> <span class=\"token operator\">*</span>Circle<span class=\"token punctuation\">:</span>\n  \tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">case</span> <span class=\"token operator\">*</span>Rectangle<span class=\"token punctuation\">:</span>\n  \tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">case</span> <span class=\"token keyword\">default</span><span class=\"token punctuation\">:</span>\n  \tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>switch 后面可以跟一个变量, case 可以跟一个或者多个常量表达式.</p>\n","feature":true,"text":"Golang Tutorial 8类型的 String 方法和格式化描述符String()方法当定义了一个具有很多方法的类型时, 常常也会实现一个 String()方法来定制类型的字符串形式的输出. 如果一个类型定义了 String()方法,那么它会被 fmt.Printf()当...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[{"name":"Golang","slug":"Golang","count":9,"path":"api/categories/Golang.json"}],"tags":[{"name":"Programming Language","slug":"Programming-Language","count":9,"path":"api/tags/Programming-Language.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Golang-Tutorial-8\"><span class=\"toc-text\">Golang Tutorial 8</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E5%9E%8B%E7%9A%84-String-%E6%96%B9%E6%B3%95%E5%92%8C%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%8F%8F%E8%BF%B0%E7%AC%A6\"><span class=\"toc-text\">类型的 String 方法和格式化描述符</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#String-%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">String()方法</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8%E5%80%BC%E6%8E%A5%E6%94%B6%E8%80%85%E5%92%8C%E6%8C%87%E9%92%88%E6%8E%A5%E6%94%B6%E8%80%85%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%B7%AE%E5%BC%82\"><span class=\"toc-text\">使用值接收者和指针接收者实现接口的差异</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%80%BC%E7%B1%BB%E5%9E%8B%E6%8E%A5%E6%94%B6%E8%80%85%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">值类型接收者实现接口</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%E6%8E%A5%E6%94%B6%E8%80%85%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">指针类型接收者实现接口</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%A9%BA%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">空接口:</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80\"><span class=\"toc-text\">类型断言</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8-type-swithc-%E6%9D%A5%E8%BF%9B%E8%A1%8C%E5%A4%9A%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD\"><span class=\"toc-text\">使用 type-swithc 来进行多值类型判断</span></a></li></ol></li></ol></li></ol></li></ol>","author":{"name":"Hccc丶","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"曾经沧海难为水, 除却巫山不是云<br/>取次花丛懒回顾, 半缘修道半缘君","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"github":{"icon":"/svg/github.svg","link":"https://github.com/HiChen85"},"bilibili":{"icon":"/svg/logo.svg","link":"https://space.bilibili.com/512394874"}}}},"mapped":true,"prev_post":{"title":"Golang Tutorial 9","uid":"b9ad58d220db9597427a33bc2b1eea6a","slug":"Golang-Tutorial-9","date":"2021-09-15T09:37:40.000Z","updated":"2021-09-16T07:05:29.094Z","comments":true,"path":"api/articles/Golang-Tutorial-9.json","keywords":null,"cover":"/img/5.jpg","text":"Golang Tutorial 9 Function函数的可变参数在 Go 语言中, 函数可以指定一个不定长参数来接收多个同类型参数. 但是这个参数需要放在其他固定参数的最后. 本质上这个可变参数的实现是通过 slice. 所以在接收参数后也应当以切片对待 可变参数的定义func...","link":"","photos":[],"count_time":{"symbolsCount":"4.7k","symbolsTime":"4 mins."},"categories":[{"name":"Golang","slug":"Golang","count":9,"path":"api/categories/Golang.json"}],"tags":[{"name":"Programming Language","slug":"Programming-Language","count":9,"path":"api/tags/Programming-Language.json"}],"author":{"name":"Hccc丶","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"曾经沧海难为水, 除却巫山不是云<br/>取次花丛懒回顾, 半缘修道半缘君","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"github":{"icon":"/svg/github.svg","link":"https://github.com/HiChen85"},"bilibili":{"icon":"/svg/logo.svg","link":"https://space.bilibili.com/512394874"}}}},"feature":true},"next_post":{"title":"Golang Tutorial 7","uid":"de3eee39821c26516f0a3be9bd55d485","slug":"Golang-Tutorial-7","date":"2021-09-14T07:52:44.000Z","updated":"2021-09-14T10:09:27.880Z","comments":true,"path":"api/articles/Golang-Tutorial-7.json","keywords":null,"cover":"/img/7.jpg","text":"Golang Tutorial 7 继承与多态Golang 中的继承在 Go 中,继承实际是由类型组合来实现的, 根据前一节的内容, Go 的结构体中支持匿名字段, 由类型名作为字段名,且在实际使用时, 可以被省略. 下面以一个动物的例子来展示如何使用继承. 同时使用一个汽车的例...","link":"","photos":[],"count_time":{"symbolsCount":"3.4k","symbolsTime":"3 mins."},"categories":[{"name":"Golang","slug":"Golang","count":9,"path":"api/categories/Golang.json"}],"tags":[{"name":"Programming Language","slug":"Programming-Language","count":9,"path":"api/tags/Programming-Language.json"}],"author":{"name":"Hccc丶","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"曾经沧海难为水, 除却巫山不是云<br/>取次花丛懒回顾, 半缘修道半缘君","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"github":{"icon":"/svg/github.svg","link":"https://github.com/HiChen85"},"bilibili":{"icon":"/svg/logo.svg","link":"https://space.bilibili.com/512394874"}}}},"feature":true}}