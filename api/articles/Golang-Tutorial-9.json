{"title":"Golang Tutorial 9","uid":"b9ad58d220db9597427a33bc2b1eea6a","slug":"Golang-Tutorial-9","date":"2021-09-15T09:37:40.000Z","updated":"2021-09-16T07:05:29.094Z","comments":true,"path":"api/articles/Golang-Tutorial-9.json","keywords":null,"cover":"/img/5.jpg","content":"<h1 id=\"Golang-Tutorial-9-Function\"><a href=\"#Golang-Tutorial-9-Function\" class=\"headerlink\" title=\"Golang Tutorial 9 Function\"></a>Golang Tutorial 9 Function</h1><h2 id=\"函数的可变参数\"><a href=\"#函数的可变参数\" class=\"headerlink\" title=\"函数的可变参数\"></a>函数的可变参数</h2><p>在 Go 语言中, 函数可以指定一个不定长参数来接收多个同类型参数. 但是这个参数需要放在其他固定参数的最后. 本质上这个可变参数的实现是通过 slice. 所以在接收参数后也应当以切片对待</p>\n<h4 id=\"可变参数的定义\"><a href=\"#可变参数的定义\" class=\"headerlink\" title=\"可变参数的定义\"></a>可变参数的定义</h4><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">A</span><span class=\"token punctuation\">(</span>a <span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> b <span class=\"token builtin\">float64</span><span class=\"token punctuation\">,</span> items <span class=\"token operator\">...</span><span class=\"token keyword\">interface</span><span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">for</span> i<span class=\"token punctuation\">,</span> v <span class=\"token operator\">:=</span> items <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">// do something</span>\n  <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>在上述代码中,使用<code>...</code>来标识一个形参是可变参数. 在函数体内部,这个变量被当做所有可变参数的一个 slice. 可以直接对这个变量进行 for-range 迭代.</p>\n<h4 id=\"可变参数的传入\"><a href=\"#可变参数的传入\" class=\"headerlink\" title=\"可变参数的传入\"></a>可变参数的传入</h4><ol>\n<li><p>直接传入多个参数.</p>\n<p>fmt.Println()函数可一次性打印多个变量.就是定义了一个可以接收可变参数的空接口变量. 其函数签名如下</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>a <span class=\"token operator\">...</span><span class=\"token keyword\">interface</span><span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span>n <span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> err <span class=\"token builtin\">error</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></li>\n<li><p>传入一个切片</p>\n<p>可以向定义了可变参数的函数中传入一个切片</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">PrintArray</span><span class=\"token punctuation\">(</span>array <span class=\"token operator\">...</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n\t<span class=\"token keyword\">for</span> i<span class=\"token punctuation\">,</span> v <span class=\"token operator\">:=</span> <span class=\"token keyword\">range</span> array <span class=\"token punctuation\">&#123;</span>\n\t\tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">,</span> v<span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\narr1 <span class=\"token operator\">:=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">&#123;</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">&#125;</span>\n<span class=\"token function\">PrintArray</span><span class=\"token punctuation\">(</span>arr<span class=\"token operator\">...</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ol>\n<h2 id=\"高阶函数\"><a href=\"#高阶函数\" class=\"headerlink\" title=\"高阶函数\"></a>高阶函数</h2><p>所谓高阶函数是指返回值为函数的函数或者接收函数作为参数的函数.</p>\n<p>将函数作为参数的高阶函数, 最常见的一种用法就是在处理某一个 web 请求时, 匹配路由对应的处理函数.例如咋 gin 框架中一般是在对应路由上传递一个匿名函数, 但是也可以定义好一个处理函数,然后直接传入该函数的函数名, 因为之前提到过, 函数作为一种类型, 其函数名就是他的变量名</p>\n<p>函数作为返回值的高阶函数一般是用于闭包上.</p>\n<h3 id=\"匿名函数\"><a href=\"#匿名函数\" class=\"headerlink\" title=\"匿名函数\"></a>匿名函数</h3><p>不带函数名的函数, 语法格式如下</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\"><span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span>参数列表<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span>返回值列表<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>匿名函数的参数列表要紧靠 func 关键字, 当返回值列表只有一个返回值时, 括号可以省略.</p>\n<h3 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h3><p>所谓闭包是指: 函数+ 引用环境.</p>\n<p>什么是引用环境? 是指作为返回值的函数内部, 使用并返回了其外部函数的变量. </p>\n<p>此时, 这个<strong>外部函数返回的函数</strong>称为闭包.</p>\n<p>在闭包的生命周期内, 他引用的环境(他外部函数的变量)将始终存在.</p>\n<h4 id=\"闭包实例1\"><a href=\"#闭包实例1\" class=\"headerlink\" title=\"闭包实例1\"></a>闭包实例1</h4><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\"><span class=\"token comment\">// 实现一个加法器闭包</span>\n<span class=\"token keyword\">func</span> <span class=\"token function\">adder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token builtin\">int</span> <span class=\"token punctuation\">&#123;</span>\n\tx <span class=\"token operator\">:=</span> <span class=\"token number\">0</span>\n\t<span class=\"token keyword\">return</span> <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span>y <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token builtin\">int</span> <span class=\"token punctuation\">&#123;</span>\n\t\tx <span class=\"token operator\">+=</span> y\n\t\t<span class=\"token keyword\">return</span> x\n\t<span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n\ta <span class=\"token operator\">:=</span> <span class=\"token function\">adder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\tlog<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token function\">a</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\tlog<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token function\">a</span><span class=\"token punctuation\">(</span><span class=\"token number\">20</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  \n  a2 <span class=\"token operator\">:=</span> <span class=\"token function\">adder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  log<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token function\">a</span><span class=\"token punctuation\">(</span><span class=\"token number\">30</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\tlog<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token function\">a</span><span class=\"token punctuation\">(</span><span class=\"token number\">40</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>adder()是一个返回闭包的函数, 内部带有闭包的引用环境<code>x</code>, 当每次调用闭包函数时, 相同闭包共享同一个引用环境, 所以 <code>x</code>的值被记录下来, 直到这个闭包函数被回收. a 与 a2 是两个不同的闭包.</p>\n<h4 id=\"闭包实例-2\"><a href=\"#闭包实例-2\" class=\"headerlink\" title=\"闭包实例 2\"></a>闭包实例 2</h4><pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">makeSuffix</span><span class=\"token punctuation\">(</span>suffix <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span> <span class=\"token builtin\">string</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span>fileName <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span> <span class=\"token builtin\">string</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token operator\">!</span>strings<span class=\"token punctuation\">.</span><span class=\"token function\">HasSuffix</span><span class=\"token punctuation\">(</span>fileName<span class=\"token punctuation\">,</span> suffix<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n      <span class=\"token keyword\">return</span> fileName <span class=\"token operator\">+</span> suffix\n    <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">&#123;</span>\n      <span class=\"token keyword\">return</span> fileName\n    <span class=\"token punctuation\">&#125;</span>\n  <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n  b <span class=\"token operator\">:=</span> <span class=\"token function\">makeSuffix</span><span class=\"token punctuation\">(</span><span class=\"token string\">\".jpg\"</span><span class=\"token punctuation\">)</span>\n\tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token function\">b</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"b.jpg\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token function\">b</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"ax\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token comment\">// 这里再贴上 strings 包中的 HasPrefix 和 HasSuffix 的源码</span>\n<span class=\"token comment\">// 本质还是切片操作. 就是这么朴实无华且枯燥</span>\n<span class=\"token comment\">// HasPrefix tests whether the string s begins with prefix.</span>\n<span class=\"token keyword\">func</span> <span class=\"token function\">HasPrefix</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">,</span> prefix <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span> <span class=\"token builtin\">bool</span> <span class=\"token punctuation\">&#123;</span>\n\t<span class=\"token keyword\">return</span> <span class=\"token function\">len</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span> <span class=\"token operator\">>=</span> <span class=\"token function\">len</span><span class=\"token punctuation\">(</span>prefix<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> s<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">:</span><span class=\"token function\">len</span><span class=\"token punctuation\">(</span>prefix<span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> prefix\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token comment\">// HasSuffix tests whether the string s ends with suffix.</span>\n<span class=\"token keyword\">func</span> <span class=\"token function\">HasSuffix</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">,</span> suffix <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span> <span class=\"token builtin\">bool</span> <span class=\"token punctuation\">&#123;</span>\n\t<span class=\"token keyword\">return</span> <span class=\"token function\">len</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span> <span class=\"token operator\">>=</span> <span class=\"token function\">len</span><span class=\"token punctuation\">(</span>suffix<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> s<span class=\"token punctuation\">[</span><span class=\"token function\">len</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token operator\">-</span><span class=\"token function\">len</span><span class=\"token punctuation\">(</span>suffix<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> suffix\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>总结:</strong></p>\n<p><strong>在闭包中, 只需主要,内部返回的函数需要将外部引用环境一并返回才能保证闭包的特性. 外部引用环境可以是外部函数的形参.</strong></p>\n<h3 id=\"defer-语句\"><a href=\"#defer-语句\" class=\"headerlink\" title=\"defer 语句\"></a>defer 语句</h3><p>defer 关键字会将其后跟随的程序语句延迟处理. 在 defer 修饰的函数即将返回时, 所有被延迟处理的语句执行顺序为 defer 定义顺序的逆序. 类似于栈的后进先出原则. 简言之:先定义的 defer 后执行,后定义的 defer 语句先执行.</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\"><span class=\"token comment\">// 简单例子</span>\n<span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n\tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"start...\"</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">defer</span> fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"1...\"</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">defer</span> fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"2...\"</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">defer</span> fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"3...\"</span><span class=\"token punctuation\">)</span>\n\tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"end...\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token comment\">// 输出结果为</span>\n<span class=\"token comment\">// star...</span>\n<span class=\"token comment\">// end...</span>\n<span class=\"token comment\">// 3...</span>\n<span class=\"token comment\">// 2...</span>\n<span class=\"token comment\">// 1...</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>因为 defer 具备的这种延迟处理的能力, 所以常用于与资源释放有关的场景,比如释放数据库链接, 关闭打开的文件等</p>\n<h4 id=\"defer-执行的时机\"><a href=\"#defer-执行的时机\" class=\"headerlink\" title=\"defer 执行的时机\"></a>defer 执行的时机</h4><p>在 Go 中, return语句并非原子操作(不可在分割,必须完成执行完成的操作), 在底层,return 语句分成两步:</p>\n<ol>\n<li><p>给返回值赋值</p>\n<p><code>return x</code>这一操作中, 先将x 的值赋值给真正的返回值.</p>\n</li>\n<li><p>RET 指令</p>\n<p>真正的将返回值返回</p>\n</li>\n</ol>\n<p>defer 语句执行的时机是在 RET 操作之前, 赋值返回值之后.</p>\n<h4 id=\"defer-修饰的函数\"><a href=\"#defer-修饰的函数\" class=\"headerlink\" title=\"defer 修饰的函数\"></a>defer 修饰的函数</h4><p>一个函数如果<strong>未指明返回值的变量名</strong>,而且<strong>返回值以变量方式返回</strong>, 那么函数内部如果存在 defer 修饰的函数操作了最终的返回值,则实际的返回值仍然是原来的返回值. defer 语句的操作不影响返回结果. <strong>这是因为 defer 发生在返回值赋值过程之后, 如果未指明变量名, 则 return 语句已经把结果返回给了内存, 这时,再对变量操作也不会再有新的值被返回,只能等待 defer 之后的 RET 操作返回之前的返回值.</strong></p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">f1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token builtin\">int</span> <span class=\"token punctuation\">&#123;</span>\n\tx <span class=\"token operator\">:=</span> <span class=\"token number\">5</span>\n\t<span class=\"token keyword\">defer</span> <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n\t\tx<span class=\"token operator\">++</span>\n\t<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">return</span> x\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这段代码的最终返回值仍然是 5</p>\n<p><strong>一个函数如果指明了返回值的变量名, 且返回值以常量形式返回时</strong>, 这个常量在 return 操作时将被赋值给指明了的返回值变量.然后执行 RET 操作.如果此时存在 defer 语句操作这个返回值变量名, 那么由于这个变量名就是指向最终返回值的一块内存,defer 中的操作会影响最终的返回值结果.</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">f2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span>x <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n\t<span class=\"token keyword\">defer</span> <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n\t\tx<span class=\"token operator\">++</span>\n\t<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">return</span> <span class=\"token number\">5</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这段代码的最终结果为 6</p>\n<h4 id=\"代码总结\"><a href=\"#代码总结\" class=\"headerlink\" title=\"代码总结:\"></a>代码总结:</h4><p>上述代码的区别在于一个内部包含 defer 语句操作返回值的函数是否指定了返回值名称. 如果指明了返回值名称,则这个变量名会指向一块分配好的内存来存储返回值. 若未知名返回值名称, 在函数返回时同样会分配一块内存存储返回值,但是没有额外的变量来表示它.</p>\n<p>f1()中返回的是一个由局部变量表示的值, 在 return 时, 这个 x 的值被赋值给了一块没有显式变量表示的内存. defer 对 x 的操作并不影响返回值的那块内存.只影响 x 的局部变量所在的内存. 所以返回值不收影响.</p>\n<p>f2()中, 由于显式的声明了返回值的一个变量名,所以在函数返回时,常量被赋值给了 x, 而 x 就标识着返回值所在的那块内存, 如果对这个变量进行操作, 就会影响最终的返回值.</p>\n<h4 id=\"defer-的另一特性\"><a href=\"#defer-的另一特性\" class=\"headerlink\" title=\"defer 的另一特性\"></a>defer 的另一特性</h4><p>用 defer 注册延迟处理的函数时,函数的所有参数值都必须被确定. 如果有计算,就要得到计算结果后再注册.</p>\n<p>defer 修饰的函数参数被注册后,就不可再被更改了.</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">calc</span><span class=\"token punctuation\">(</span>index <span class=\"token builtin\">string</span><span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">,</span> b <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token builtin\">int</span> <span class=\"token punctuation\">&#123;</span>\n\tret <span class=\"token operator\">:=</span> a <span class=\"token operator\">+</span> b\n\tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>index<span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">,</span> ret<span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">return</span> ret\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n  x<span class=\"token punctuation\">,</span> y <span class=\"token operator\">:=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span>\n\t<span class=\"token keyword\">defer</span> <span class=\"token function\">calc</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"AA\"</span><span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">,</span> <span class=\"token function\">calc</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"A\"</span><span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\tx <span class=\"token operator\">=</span> <span class=\"token number\">10</span>\n\t<span class=\"token keyword\">defer</span> <span class=\"token function\">calc</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"BB\"</span><span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">,</span> <span class=\"token function\">calc</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"B\"</span><span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\ty <span class=\"token operator\">=</span> <span class=\"token number\">20</span>\n<span class=\"token punctuation\">&#125;</span>\nA <span class=\"token number\">1</span> <span class=\"token number\">2</span> <span class=\"token number\">3</span>\nB <span class=\"token number\">10</span> <span class=\"token number\">2</span> <span class=\"token number\">12</span>\nBB <span class=\"token number\">10</span> <span class=\"token number\">12</span> <span class=\"token number\">22</span>\nAA <span class=\"token number\">1</span> <span class=\"token number\">3</span> <span class=\"token number\">4</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>上述代码中首先执行了第 8 行的第三个参数处的函数调用, 并且将其返回值确定后用于 defer 注册, 此时 defer 注册的外部函数的三个参数分别为<code>AA</code> <code>x=1</code> <code>3</code>.</p>\n<p>接着执行 第9行. 需要注意的是,即便 x 的值被更改了, 但 defer 注册了的函数实参并不会被改变. 第 8 行处 x 的值仍然是注册时的值 1. </p>\n<p>接着执行第 10 行中的第三个参数处的函数调用,此时 还未进行注册, 需要先确定函数的返回值,因此 x 的值为 10, y 的值为 2, 返回值为 12. 然后进入到 defer 注册过程, 外部函数的参数需要被确定下来,<code>BB</code> <code>x=10</code> <code>12</code>.</p>\n<p>然后执行 y=20, 虽然 y 执行了,但 defer 注册后并未再使用该值,所以紧接着执行 defer 注册.</p>\n<p>根据 defer 机制,先执行第2个 defer, 也就是<code>&quot;BB&quot;</code>这一行,这里 x 的值为 10, 函数返回值为 12, 所以最终打印结果是 22.</p>\n<p>紧接着执行第1 个 defer, x=1, 返回值为 3, 所以最终的打印结果是 4</p>\n","feature":true,"text":"Golang Tutorial 9 Function函数的可变参数在 Go 语言中, 函数可以指定一个不定长参数来接收多个同类型参数. 但是这个参数需要放在其他固定参数的最后. 本质上这个可变参数的实现是通过 slice. 所以在接收参数后也应当以切片对待 可变参数的定义func...","link":"","photos":[],"count_time":{"symbolsCount":"4.7k","symbolsTime":"4 mins."},"categories":[{"name":"Golang","slug":"Golang","count":9,"path":"api/categories/Golang.json"}],"tags":[{"name":"Programming Language","slug":"Programming-Language","count":9,"path":"api/tags/Programming-Language.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Golang-Tutorial-9-Function\"><span class=\"toc-text\">Golang Tutorial 9 Function</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">函数的可变参数</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">可变参数的定义</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E7%9A%84%E4%BC%A0%E5%85%A5\"><span class=\"toc-text\">可变参数的传入</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">高阶函数</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">匿名函数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%97%AD%E5%8C%85\"><span class=\"toc-text\">闭包</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%97%AD%E5%8C%85%E5%AE%9E%E4%BE%8B1\"><span class=\"toc-text\">闭包实例1</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%97%AD%E5%8C%85%E5%AE%9E%E4%BE%8B-2\"><span class=\"toc-text\">闭包实例 2</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#defer-%E8%AF%AD%E5%8F%A5\"><span class=\"toc-text\">defer 语句</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#defer-%E6%89%A7%E8%A1%8C%E7%9A%84%E6%97%B6%E6%9C%BA\"><span class=\"toc-text\">defer 执行的时机</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#defer-%E4%BF%AE%E9%A5%B0%E7%9A%84%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">defer 修饰的函数</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">代码总结:</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#defer-%E7%9A%84%E5%8F%A6%E4%B8%80%E7%89%B9%E6%80%A7\"><span class=\"toc-text\">defer 的另一特性</span></a></li></ol></li></ol></li></ol></li></ol>","author":{"name":"Hccc丶","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"曾经沧海难为水, 除却巫山不是云<br/>取次花丛懒回顾, 半缘修道半缘君","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"github":{"icon":"/svg/github.svg","link":"https://github.com/HiChen85"},"bilibili":{"icon":"/svg/logo.svg","link":"https://space.bilibili.com/512394874"}}}},"mapped":true,"prev_post":{"title":"DataStructure 01","uid":"2e282140550dbaba095df242e62ffa5e","slug":"DataStructure-Algorithm-01","date":"2021-09-18T16:42:03.000Z","updated":"2021-09-20T08:27:59.773Z","comments":true,"path":"api/articles/DataStructure-Algorithm-01.json","keywords":null,"cover":"/img/2.jpg","text":"DataStructure 01单链表单链表是线性表的一种链式存储结构, 具有单向性,只能从前向后遍历. 单链表的特性: 单链表的尾结点的 next 域为空 做添加(在尾结点添加), 插入(任意位置), 删除(任意位置)比较容易, 查询遍历来说比较耗时. 单链表的golang 实...","link":"","photos":[],"count_time":{"symbolsCount":"2.5k","symbolsTime":"2 mins."},"categories":[{"name":"DataStructure","slug":"DataStructure","count":2,"path":"api/categories/DataStructure.json"}],"tags":[{"name":"DataStructure","slug":"DataStructure","count":2,"path":"api/tags/DataStructure.json"}],"author":{"name":"Hccc丶","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"曾经沧海难为水, 除却巫山不是云<br/>取次花丛懒回顾, 半缘修道半缘君","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"github":{"icon":"/svg/github.svg","link":"https://github.com/HiChen85"},"bilibili":{"icon":"/svg/logo.svg","link":"https://space.bilibili.com/512394874"}}}},"feature":true},"next_post":{"title":"Golang Tutorial 8","uid":"b7b9075ba8f3fce9f65889bb535dd257","slug":"Golang-Tutorial-8","date":"2021-09-14T10:10:28.000Z","updated":"2021-09-15T09:37:14.838Z","comments":true,"path":"api/articles/Golang-Tutorial-8.json","keywords":null,"cover":"/img/8.jpg","text":"Golang Tutorial 8类型的 String 方法和格式化描述符String()方法当定义了一个具有很多方法的类型时, 常常也会实现一个 String()方法来定制类型的字符串形式的输出. 如果一个类型定义了 String()方法,那么它会被 fmt.Printf()当...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[{"name":"Golang","slug":"Golang","count":9,"path":"api/categories/Golang.json"}],"tags":[{"name":"Programming Language","slug":"Programming-Language","count":9,"path":"api/tags/Programming-Language.json"}],"author":{"name":"Hccc丶","slug":"blog-author","avatar":"/img/avatar.jpg","link":"/","description":"曾经沧海难为水, 除却巫山不是云<br/>取次花丛懒回顾, 半缘修道半缘君","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"github":{"icon":"/svg/github.svg","link":"https://github.com/HiChen85"},"bilibili":{"icon":"/svg/logo.svg","link":"https://space.bilibili.com/512394874"}}}}}}