[{"id":"eaefd71f93a58b7ced195ad6747e390e","title":"Golang Tutorial 6","content":"Golang Tutorial 6Struct结构体结构体定义基本语法使用 type 和 struct 关键字来定义一个自定义的类型.\ntype Name struct&#123;\n  field1 type1\t`json:\"field1\"`\n  field2 type2\t`json:\"field2\"`\n  ...\n&#125;\n\n在程序中声明结构体类型的变量声明变量type Student struct &#123;\n  name \t\t\tstring\n  age \t\t\tint\n&#125;\n\nfunc main() &#123;\n  var s1 Student\t\t// 先声明一个结构体类型的变量.然后进行赋值\n  s1.name = \"张三\"\n  s1.age = 19\n&#125;\n\n使用 new 声明结构体变量指针go 中提供了一个语法糖, 针对结构体类型的变量, 无论是普通变量还是指针变量, 都可以直接使用.号直接访问字段.\n// var s2 *Student\n// s2 = new(Student)\ns2 := new(Student)\ns2.name = \"李四\"\ns2.age = 20\n\n需要注意的是不论new 还是直接声明结构体变量, 编译器都会为 struct 类型分配内存,因其是值类型的.\n显式初始化显式初始化的语法和 map 的显示初始化类似,不过 map 的初始化是以 key-value 形式出现,所有 key 类型都是一致的. 而结构体的内部成员冒号前面是字段名,冒号后是字段值.\ns3 := &amp;Student&#123;name:\"王五\", age:20&#125;\ns4 := &amp;Student&#123;\n  name:\"汤师爷\",\n&#125;\n\n在 s4 的声明过程中, 这种声明方式可以省略部分字段,由编译器来赋一个对应类型的 0 值.\n注: new 的作用等同于&amp;Student&#123;&#125;这样声明一个未初始化的结构体变量.\n结构体的内存布局在 go 中,结构体和它所包含的数据是被存放在连续的内存块中的,且存在一个内存对齐的机制来保证其高效性. 内存对齐机制,大致可以理解为按照一个对齐系数来对齐这块内存,如果结构体内部的数据类型之间的偏移量不是 对齐系数的整数倍,就需要补充一定的内存使其对齐.\n使用工厂方法创建结构体实例使用工厂方法创建结构体,也可以叫做为结构体类型创建构造器. 一般来说根据结构体内部的成员来显式地创建并返回一个结构体变量.工厂方法的一般规则为用New+类型名作为工厂方法, 成员变量为参数.\ntype Student struct &#123;\n  name string\n  age int\n&#125;\n\nfunc NewStudent(name string, age int) *Studnet &#123;\n  if name == \"\" &#123;\n    return nil\n  &#125;\n  return &amp;Student&#123;name:name, age:age&#125;\n&#125;\n\n// 使用 new 的 构造函数或工厂方法\nfunc NewStudent(name string, age int) *Student &#123;\n  if name == \"\" &#123;\n    return nil\n  &#125;\n  student := new(Student)\n  student.name = name\n  student.age = age\n  return student\n&#125;\n\n匿名字段与内嵌结构体go 语言结构体可以包含一个或者多个匿名字段,简言之,匿名字段就是没有字段名,只有字段类型. 而此时,类型名就是字段名. 匿名字段也可以是一个结构体类型, 从而有了所谓的内嵌结构体.\n在每一个结构体中,因为字段名必须唯一, 所以同种数据类型只能有一个匿名字段.\n而匿名字段这一特性在 go 中被用来模拟 OOP 中的继承行为. 在 go 中,继承是通过内嵌结构体和类型组合来实现的.\ntype Address struct &#123;\n  Province \tstring\n  City \t\t\tstring\n&#125;\n\ntype Person struct &#123;\n  name string\n  age int\n  Address\t\t// 嵌套一个匿名字段\n&#125;\n\nfunc main() &#123;\n  p1 := new(Person)\n  p1.name = \"张麻子\"\n  p1.age = 40\n  p1.Address.Province = \"广东省\"\n  p1.City = \"鹅城\"\t\t// 省略了内嵌匿名字段名\n  fmt.Println(p1)\n&#125;\n\n从上述代码可以看出, 当访问匿名字段类型内的数据时,可以省略这个匿名字段,直接由外部类型来访问内嵌匿名类型的字段.\n类型方法Go 中所说的方法是作用在一个叫做 receiver 上的函数. Receiver(接收者)是特定类型的变量或者指针变量. 它绑定了函数来展示它所具备的功能.\n当前的go 版本 1.17支持值类型变量或者指针变量调用值类型接收者的方法或者指针类型接收者的方法. 没有限制. 但个人认为在不涉及修改结构体实例的内部数据时,使用值类型接收者.\ntype Dog struct &#123;\n  name string\n&#125;\n\n// 构造一个工厂方法或者叫构造函数\nfunc NewDog (name string) *Dog &#123;\n  return &amp;Dog&#123;name:name&#125;\n&#125;\n\n// 设置改变私有变量的导出方法.\nfunc (this *Dog) SetName(name string) &#123;\n  this.name = name\n&#125;\n\n// 值类型接收者以及方法\nfunc (d Dog) GetName() string &#123;\n\treturn d.name\n&#125;\n\nfunc (this *Dog) move() &#123;\n  fmt.Println(this.name, \"move to the door\")\n&#125;\n\ntype Leader struct &#123;\n\tname string\n&#125;\n\nfunc NewLeader(name string) *Leader &#123;\n\treturn &amp;Leader&#123;name: name&#125;\n&#125;\n\nfunc (l *Leader) CleanUpBandit() &#123;\n\tfmt.Println(\"县长来了, 枪在手, 跟我走\")\n&#125;\n\n关于何时使用指针接收者\n当需要修改接收者中的值时\n当接收者是拷贝代价比较大的大对象\n当某个方法使用了指针类型的接收者时, 其他方法最好也是使用指针类型的接收者\n\n","slug":"Golang-Tutorial-6","date":"2021-09-13T04:16:04.000Z","categories_index":"Golang","tags_index":"Programming Language","author_index":"Hccc丶"},{"id":"21b7afb55dd7403da1611146a47b852e","title":"Golang Tutorial 5","content":"Golang Tutorila 5Map Tutorialmap 在 go语言中也是一种引用类型, 因此多使用 make 函数来创建.\n基础语法格式var m map[keyType]valueType\n\nvar studentId map[string]int\n\n同 slice 一样,如上述格式声明 map 类型后,打印结果显示,编译器为 studenId 变量分配了内存地址,但是并没有赋初值(未初始化,值为nil). 因为 map 是引用类型,需要使用 make 来为其赋初值.\n对一个值为 nil 的 slice 中添加元素是可行的, 具体做法便是使用 append 函数. 但是对于 map 来说不行.会引发 panic\nmake 方式声明 map 类型变量c = 5 // 显式指定 map 中的k-v 对的数\nvar m2 = make(map[string]int, c)\nm3 := make(map[string]string, 10)\n\n当声明完后, 此时 map 变量已经被分配了内存, 但由于未添加元素,所以是一个空的 map 但不是 nil\nmap 的 key 和 value 字段的要求key 允许的类型为 string, int, float, 或者内部字段全部为基本数据类型的结构体(目前很少用到), value 可以是任意值. 可以定义为一个空接口类型来接收各种类型的值. 因为函数在 go 中为一等公民, 因此 value 也可以接收函数类型的值. 换言之, 可以传入函数名作为 value, 这样就可以通过 key 来指定具体执行的函数,从而进行流程上的控制.\nfunc add(a, b float64) float64 &#123;\n\treturn a + b\n&#125;\n\nfunc sub(a, b float64) float64 &#123;\n\treturn a - b\n&#125;\n\nfunc mult(a, b float64) float64 &#123;\n\treturn a * b\n&#125;\n\nfunc divide(a, b float64) float64 &#123;\n\treturn a / b\n&#125;\n\n// 定义 value 为函数类型. 此处value 可以使用括号也可以不使用\nvar m3 = make(map[string] (func(float64, float64) float64) )\n\nm[\"+\"] = add\nm[\"-\"] = sub\nm[\"*\"] = mult\nm[\"/\"] = divide\n\nfmt.Println(m[\"+\"](1, 2))\n\n注: 函数也是 go 中的一种类型.可以将函数名当做函数类型的常量,可将函数明作为参数或者值传给另一些变量或者函数参数中. 在函数章节中会详细介绍.\n判断 map 中是否存在特定 key首先掌握 map 通过 key获取 value 的语法.\nvalue, ok := m[\"key\"]\n\n上述语法第一个参数为 key 对应的 value, 第二个 ok 表示 key 存在与否,当不存在时,返回 false. 存在时返回 true.\n通过上述的语法,go 中常用的用于判断某个 key 是否存在的语法如下\nif _, ok := m[\"key\"]; !ok &#123;\n  fmt.Println(\"there is no such key in m\")\n&#125;\n\n用 slice 作为 value一个应用场景为: 当以 key 为父进程的 pid 时,所有该进程的子进程(子进程 pid)就需要用 slice 来存储.\n另外需要注意的是,由于 value 也是一个引用类型,因此在使用时需要预先进行一次 make 初始化内存操作.一面报错.\nm2 := make(map[int][]int)\nm2[1] = make([]int, 5)\n\nfor i := 0; i &lt; len(m2[1]; i++)&#123;\n  m2[1][i] = i+1\t\t// 简单对 1 对应的 slice 中的元素赋值\n&#125;\n\n获取 map 中元素的个数使用 len 函数可以获取到 map 中存储的 k-v 对个数.\n对 map 的排序map 中的 key 和 value 都是无序的,如果想要对 map 排序,需要先将 map 中的 key 或者 value 取出存入一个 slice 中,然后利用sort 包对 key 进行排序. 再用循环打印出想要的序列.\n但经过测试, 在 map 中添加元素后,默认的排序方式是按照字符串首字母对应的 byte值(ASCII 码值)或者 rune 值(unicode 值)进行排序, 然后根据值得大小从小到大输出的.\nm2 := make(map[string]int)\nm2[\"Apple\"] = 100\nm2[\"Banana\"] = 101\nm2[\"cherry\"] = 102\nm2[\"date\"] = 103\nm2[\"John\"] = 101\nm2[\"Tom\"] = 102\ni := 0\nfor k, v := range m2 &#123;\nfmt.Println(k, v)\nm2[k] = 200 + i\ni++\n&#125;\nfmt.Println(m2)\n\n再看如下一段代码\nm := make(map[int]*int)\nstus := []int&#123;1, 2, 3, 4, 5&#125;\n\nfor idx, stu := range stus &#123;\n  m[idx] = &amp;stu\n&#125;\nfor k, v := range m &#123;\n  fmt.Println(k, \"=>\", *v)\n&#125;\nfmt.Println(m)\n\n这段代码最终的输出结果是所有的 key 对应的 value 都为 5, 因为其 value 部分保存的都是循环体变量的指针. 当range循环体变量循环到最后一个 slice 元素后, 复制最后一个元素的副本, 然后被保存到了 map 的 value 部分中.\n这里有两点需要注意: 1. 因为 map 变量的 value 保存了 int 的指针,所以, 循环体变量再循环到最后一个 slice 元素后并未被释放内存. 2. 因为value 保存的是地址, 循环变量的地址是指向 slice 最后一个元素的副本,因此输出结果与 slice 最后一个元素的地址也是不同的.\n","slug":"Golang-Tutorial-5","date":"2021-09-12T12:18:36.000Z","categories_index":"Golang","tags_index":"Programming Language","author_index":"Hccc丶"},{"id":"ed56a0be6c67a53488e6ffd0f75904e2","title":"Golang Tutorial 4","content":"Golang Tutorial 4切片(slice)Golang 中的切片是对数组一个连续片段的引用, 因此是引用类型. 这个连续的片段可以是整个数组,也可以是由开发者指定的开始和结束索引限定的一段连续片段. 从集合的角度来看,若数组是一个元素集合,则切片就是它的一系列非空子集.\n既然是数组的引用,那么切片本身也具备数组的一些性质.另外,切片同时也具备一些数组不具备的特质,比如可以向切片中增加元素.\n切片同时提供了可以计算切片容量的函数 cap(), 如果切片是由数组创建的, 计算方法是从切片的起始元素到数组末尾的长度.\n创建切片的方式make创建// 创建格式: make(type, len[, cap])\n// 创建一个长度为 5, 容量为 10 的切片\n// 切片容量代表的是当切片元素达到 5 时, 继续往后最多可添加的元素个数\n// 当再添加五个元素后,切片容量达到最大,此时若再向其中添加元素,则需要重新构建\n// 新的切片.因此, 在一些结构体中,可能需要使用指针接收者来指向原始的切片数据\ns1 := make([]int, 5, 10)\n\n// 切片的遍历\nfor idx, value := range s1 &#123;\n  fmt.Println(idx, value)\n&#125;\n\n显式初始化var sli1 = []int&#123;1,2,3,4,4&#125;\nsli2 := []string&#123;\"zhangsan\", \"lisi\", \"wangwu\"&#125;\n\n从数组中创建arr1 := [...]int&#123;1,2,3,4,5&#125;\nsli3 := arr1[1:3] // 方括号中的索引是包含左边不包含右边的\n// sli3 的输出结果是 2 3\n\ncopy函数利用 copy 函数可以对一个已有的切片进行拷贝,具体语法如下\nrst := make([]string, 5, 10)\ntemp := []string&#123;\"Beijing\", \"London\", \"Glasgow\"&#125;\n// copy 函数会将后续参数中的元素全部复制到第一个参数的切片中\n// copy(dest, src) // 将 src 中的元素拷贝到 dest 中\ncopy(rst, temp)\n\nappend 函数append 函数会将0 个或者多个具有相同类型的元素追加到已有的切片中,若超出了切片的容量时, 切片会发生扩容, append 会重新分配一块新的内存区域来存放整个新的切片.此时旧的切片将保持扩容到最大容量时的数据. append 函数总是成功返回的,除非内存消耗殆尽.\ns1 := make([]int, 2, 4)\nvar s2 []int\nfmt.Printf(\"%p \\n\", s2)\t//打印初始的s2 地址,由于未初始化,并未分配实际的内存地址\nfor i := 0; i &lt; 5; i++ &#123;\t// 此处设置 5 是为了测试当容量超出原始 slice 的容量时,看append 函数是否会对 slice 进行扩容并分配新的内存空间给新变量\n  if i >= len(s1) &amp;&amp; i &lt; cap(s1) &#123;\n    fmt.Println(\"长度不足,在 slice 容量内扩容\")\n    s1 = append(s1, i)\n    fmt.Printf(\"%p %v \\n\", s1, s1[i])\n  &#125; else if i &lt; len(s1) &#123;\n    fmt.Println(\"长度足够, 直接对 slice 元素赋值\")\n    s1[i] = i\n    fmt.Printf(\"%p %v \\n\", s1, s1[i])\n  &#125; else &#123;\n    fmt.Println(\"元素个数已超出原始 slice 容量, append 函数重新分配内存空间给新的 slice\")\n    s2 = append(s1, i)\n    fmt.Printf(\"%p %v\\n\", s2, s2[i])\n    fmt.Printf(\"len(s2)=%v cap(s2)=%v \\n\", len(s2), cap(s2))\n  &#125;\n&#125;\nfmt.Printf(\"%p %v\\n\", s1, s1)\nfmt.Printf(\"%p %v\\n\", s2, s2)\n\nslice 的扩容规则根据上述代码的输出结果,最终 cap=4 的 s1 在容量不足进行扩充后,s2 容量为 8.因此扩容规则为 double 原始 slice 的容量 capacity.\nnew 函数和 make 函数的区别new 函数会分配指定类型的指针给变量. 多用于结构体类型和数组等值类型变量, 相当于&amp;T&#123;&#125;,其中 T 可以是[5]int, [6]string以及 &amp;Student&#123;&#125;等自定义类型.\nnew 函数创建的指针变量值为 0x0, 若为 silce, 则 len=0, cap=0. 变量指向的实际 slice 为一个nil.而 slice 的 nil 输出为一个[].\nmake 会初始化一个slice 变量, 并分配实际内存, 创建对应类型的初值. 在不指定 cap 的时候,cap 会与 len 相等.\ntemp1 := new([]int)\nfmt.Printf(\"%p %v %v %v\\n\", *temp1, *temp1, len(*temp1), cap(*temp1))\nfmt.Println(*temp1 == nil)\ntemp2 := make([]int, 5)\nfmt.Printf(\"%p %v %v %v \\n\", temp2, temp2, len(temp2), cap(temp2))\n\n可以根据上述代码自行检验结果.\n","slug":"Golang-Tutorial-4","date":"2021-09-05T22:06:48.000Z","categories_index":"Golang","tags_index":"Programming Language","author_index":"Hccc丶"},{"id":"3983d1b06f9cc59a424cf4b8b973001f","title":"Golang Tutorial 3","content":"Golang Tutorial 3数组(Array)在 golang 中,数组是值类型变量,当作为参数传递时,会发生值拷贝,在函数体内部对数组进行修改后,并不会影响函数体外的数据\n作为强类型语言, Golang 中的数组元素必须都是相同类型,此点与 python 的 list 有所区别\n同时,作为值类型的变量类型, go 提供了 new 关键字来为其分配指针.\nGolang 中声明数组的几种方式需要注意的是,声明数组时必须指定数组元素的个数,或者在方括号[]内使用...由编译器推断具体的数组元素个数\n直接声明var arr [5]int\n// 直接声明而不初始化时, 编译器默认为数组分配 0 值\n\n这种声明方式创建的 arr 变量类型是[5]int 类型, 当直接使用 arr 传参时, 会对 arr 进行值拷贝.\n初始化显式的为数组元素指定值,可以部分指定,余下的部分自动赋值 0 值\nvar arr1 = [10]int&#123;1,2,3,4&#125;\n\n使用指定索引的方式进行初始化,未被指定的部分赋值对应类型的 0 值\nvar arr2 = [5]int&#123;0:1, 3:5&#125;\n\n使用...指定数组,编译器自动推断数组元素个数, 这种指定方式必须带有初始化,否则报错.\nvar arr3 = [...]int&#123;1,3,4,5,6&#125;\n\n多维数组二维数组func main()&#123;\n\tvar array = [3][2]string&#123;\n    &#123;\"中国\", \"北京\"&#125;,\n    &#123;\"美国\", \"华盛顿\"&#125;,\n\t\t&#123;\"英国\", \"伦敦\"&#125;,\n\t&#125;\n\n\t// 使用两种方式遍历数组\n\tfor _, value := range array &#123;\n\t\tvar builder strings.Builder\n\t\tfor i := 0; i &lt; len(value); i++ &#123;\n      // 练习使用 strings.Builder 来拼接字符串\n\t\t\tbuilder.WriteString(value[i])\n\t\t\tbuilder.WriteString(\"-\")\n\t\t&#125;\n\t\tfmt.Println(builder.String())\n\t&#125;\n&#125;\n\n需要注意的是使用 range 方式遍历可迭代的类型时, value 都是可迭代变量中元素的副本,对他的修改不会改变原始数据\n数组可变因数组支持对其内部元素的更改, 因此称其为可变的\nvar arr1 [5]int\narr1[0] = 1\n\n","slug":"Golang-Tutorial-3","date":"2021-09-03T07:30:17.000Z","categories_index":"Golang","tags_index":"Programming Language","author_index":"Hccc丶"},{"id":"f20d4f48999b3be7c6a4f7d5c95630f9","title":"Golang Tutorial 2","content":"Golang 的 String 详解本章介绍 Go 语言中 string 相关的内容. 包括字符串创建, 修改, 遍历和转换等操作\n\n\nUnicode in Go在 go 中支持 Unicode(UTF-8), 因此字符也称为 Unicode 码点或者runes, 在内存中用 int32 表示.但具体每隔字符占据多少字节是不一样的.一个中文在 go 中占据 3 个字节.\nrune 类型与 byte 类型rune 类型在 go 语言底层实现是一个 int32类型, 它仅仅是一个 int32 的别名. byte 类型底层实现是一个 uint8类型.它也是一个别名\ntype byte = uint8\ntype rune = int32\n\n零值String 类型的 0 值是一个长度为 0 的字符串&quot;&quot;.因为 go 中 string 是值类型,所以 0 值不是 nil,无法与 nil 进行比较.\n字符串比较一般的字符串比较, 实际是通过在内存中比较字节来实现的. 比如&gt;=, &lt;= , == , !=.\n字符串单个字符的获取字符串单个字符的获取可以通过索引的方式[]来获取,但需要注意的是,在中文字符中,由于一个字符占据三个字节,所以一定要知道在包含中文的字符中,两个字符之间的索引间距不一定是 1,可能是 3\n使用 range 遍历字符串在使用 range 遍历字符串时,以字符为单位进行遍历,也就是说,在返回的 i, 和 v 中,i 的值并不都是规律的\n字符串拼接+ 拼接使用这种拼接方式的缺点在于: 字符串一旦定义就不可更改,有时为了获取最终字符会产生很多的无用字符串,为程序带来 gc 的压力,性能相对较差.\nstr1 := \"hello\"\nstr2 := \"world\"\nstr3 := str1 + str22\n\n使用 fmt.Sprintf()此函数内部逻辑较为复杂,判断条件众多, 使用[]byte 实现,性能一般\nfmt.Sprintf(\"%d %s\", 2021, \"年\")\n\nstrings.Join()strings.Join([]string&#123;\"你好\", \"golang\"&#125;, \"-\")\n\n此函数会根据字符串切片的内容,计算一个拼接之后的总长度,然后申请对应内存大小的内存区域,一个个的填入拼接后的字符串.\n在已有一个字符串切片的情况下,这个效率很搞,但是若本身并没有待拼接的字符串时,创建该数组的代价很大.\nJoin 函数在拼接字符串时,会在每个切片元素之间插入一个空字符串&quot;&quot;, 然后根据第二个参数指定的字符串进行替换.\nvar arrKeyValue = [5]string&#123;2: \"Chris\", 4: \"Ron\"&#125;\nfmt.Println(strings.Join(arrKeyValue[:], \",\"))\n\n上述代码利用指定数组元素索引的方式初始化了数组,然后利用切片特性将数组转化为切片.输出结果为\n,,Chris,,Ron \n// Ron 前面一个逗号是 Join 函数添加的,因为要在两个字符之间添加一个空字符串\n// Chris 前的两个逗号和后面的第一个逗号是原本初始化数组时默认给定的字符串 0 值\n// 在Join 函数内统一将 \"\" 替换为了指定的字符串\n\nbytes.Buffer()与 strings.Builder()在介绍 bytes.Buffer 和 strings.Builder()之前,先讨论一下 Golang 中的 Pointer 类型, 以及通过 Pointer 对同一块内存数据进行类型转换的方式.\nunsafe.Pointerunsafe.Pointer 代表任意一种类型的指针, 它有四种特殊操作:\nA pointer value of any type can be converted to a Pointer\nA Pointer instance can be converted to a pointer value of any type.\nA uintptr can be converted to a Pointer.\nA Pointer can be converted to a uintptr.\n\n类型转换模式上述的四个操作意思可以简单对应于如下形式\n*T1 => Pointer => *T2\n\n借助Pointer,可以实现一个指针类型的变量到另一个指针类型变量的转换.在这种转换模式中需要保证的是转换后指针类型的T2 的内存 &lt;= T1 的内存. 而且,转换前后两个类型的变量公用同一个内存数据.\nstring 和 []byte 转换var b = []byte&#123;'a', 'b', 'c', 'd'&#125; // 注意这里是单引号\n// 这个步骤就将一个 byte 的 slice 转换成了一个 string 变量,且二者公用同一个快内存数据.\n// 一旦 b 被更改,则 s 随之更改\n// 因为 string 本身是一个不可变的,所以不能对 s 做任何的修改操作.\ns := *(*string)(unsafe.Pointer(&amp;b))\nfmt.Println(\"b: \", b)\nfmt.Println(\"s: \", s)\n// 结果相同\n// 现在修改 b 中的数据\nb[3] = \"z\"\nfmt.Println(\"b: \", b)\nfmt.Println(\"s: \", s)\n// b 与 s 都发生了变化\n// 给 s 赋一个新的值, b 不会发生变化,因为 s 是 string 类型,赋新值会创建一个新的 string实例\ns = \"ABCD\"\nfmt.Println(\"b: \", b) // abcz\nfmt.Println(\"s: \", s) // ABCD\n\nbytes.Buffer和 strings.Builder 的用法// bytes.Buffer\nvar buffer bytes.Buffer\nbuffer.WriteString(\"hello\")\nbuffer.WriteString(\",\")\nbuffer.WriteString(\"中国\")\nbuffer.WriteString(\"!!!\")\nfmt.Println(buffer.String())\n\n// strings\nvar builder strings.Builder\nbuilder.WriteString(\"ABCD\")\nbuilder.WriteString(\"-\")\nbuilder.WriteString(\"EFGH\")\nfmt.Println(builder.String())\n\nstrings.Builder()底层实现func (b *Builder) String() string &#123;\n\treturn *(*string)(unsafe.Pointer(&amp;b.buf))\n&#125;\n\n由于是在同一块内存上操作,性能比 bytes.Buffer有所提升\n[]byte, []rune 与 string 的相互转化[]byte 与 string 的相互转化// []byte 转为 string\n// 第一种借助 unsafe.Pointer 方式转化\nvar bStr = []byte&#123;'a', 'b', 'c'&#125;\ns1 := *(*string)(unsafe.Pointer(&amp;bStr))\n// 第二种直接用类型转换强转\ns2 = string(bStr)\n\n// string 转为[]byte\nstr := \"这是 string\"\nbStr2 := []byte(str)\n// 这里的转换会创建一块新内存来对 bStr2 赋值,与 str 独立\n// 对 bStr3 的操作,不会影响原本字符串的数据\ns2 := \"hello Golang\"\nbStr3 := []byte(s2)\nfmt.Println(bStr3)\nbStr3[11] = 104\nfmt.Println(s2)\nfmt.Println(string(bStr3))\n\n从上述代码可以得到的结论: 直接使用类型转换时,会产生对原始数据的拷贝,因此对新数据的修改([]byte的修改,因为 string 是不可修改的)不会影响原本的字符串数据.\n换句话说,也正是为了保证 string 不可变的这种一致性,所以才会在进行类型转换时产生数据的拷贝\n[]rune 与 string 的转化​    []rune 与 string 的转化与[]byte 类似,只需要将 byte 换成 rune 即可\n","slug":"Golang-Tutorial-2","date":"2021-09-02T22:10:10.000Z","categories_index":"Golang","tags_index":"Programming Language","author_index":"Hccc丶"},{"id":"940d915bf94905eae8346cbc13db5243","title":"Golang tutorial 1","content":"Golang Tutorial 1Golang Constant Keywordsconst PI float64 = 3.1415926\n\n特殊常量: iotaconst (\n\ta = iota\t// iota 第一次出现时为 0,\n  b\t\t\t\t\t// b = 1\n  c\t\t\t\t\t// c = 2\n  d = 10\n  e\t\t\t\t\t// e = 10\n  f\t\t\t\t\t// f = 10\n)\n\n上述代码中的为 iota 的简单使用, iota 第一次出现时,初值为 0, 后续如果不为新的常量设置初值,则 iota 会递增, 直至遇到一个显式赋值的常量. iota 不在自增.\n典型的 iota 使用案例const Byte = 1\nconst (\n  _ = iota\n  KB = Byte &lt;&lt; (10*iota)\n  MB\n  GB\n  TB\n  PB\n)\n\nGolang variables Keywords在 go 中,所有的变量在定义之后,若没有显式赋值,则为该类型的0 值.\n如果只定义了变量而未在程序中使用,则编译不能通过\n/*\n\t第一种变量声明方式,\n\t对于基本类型来说,编译器可以直接进行推断,对于复杂类型,\n*/\nvar a int;\na = 10\nvar b float32 = 10.55\n\n/*\n\t第二种变量声明方式, 多用于函数体内\n*/\nc := \"Hello World\"\n\n/*\n\t一次性声明多个变量, 在声明变量时,括号内部如果为多行,则不需要等号\n*/\nvar (\n\ta int\n  b int\n  c float64\n)\n// 或者可以使用如下方式定义多个同种类型的变量\nvar a, b int\n\nGo 也支持对变量的同时(并行)赋值\na, b, c := 1,2, \"你好\"\n\n特殊变量// _ 下划线变量为一个只写变量,当我们有时不需要使用某些函数返回的部分返回值时,可以使用_来抛弃不需要的返回值\nfor _, value := range [1,2,3,4,5] &#123;\n  // 在使用 range 关键字时, 会对被遍历的可迭代元素产生两个值,\n  // 如果是 slice 或者 array, 则第一个值为元素索引,第二个值\n  // 为元素值.\n  // 如果被迭代对象为 map, 则第一个值为 key, 第二个值为 value.\n  // 如果是字符串, 则第一个值为单个 unicode 字符的起始索引,\n  // 因为 unicode 在 go 语言中占据长度不同, range 每次只能遍历一个字符,\n  // 所以,在 遍历字符串变量时, 第一个值可能并不连续.\n  fmt.Println(value)\t\n&#125;\n\nGolang Basic Datatypebool类型var varName bool = true\nif varName &#123;\n  fmt.Println(\"true\")\n&#125; else &#123;\n  fmt.Println(\"false\")\n&#125;\n\n数值型在 golang 中, 默认不写类型名时, 浮点数的类型为 float64. 与操作系统的位数有关.\nvar a1 int = 100\nvar a2 = 200\na3 := 300\nfmt.Println(a1, a2, a3)\n\nvar b1 float32 = 12.88\nvar b2 float64 = 3.1415926\nvar b3 = 8221.441  // 默认类型为 float64\nb4 := 741.245312353\n\n字符串golang 中的字符串是由单个字节连接起来的(英语字符), Go的字节使用 UTF-8编码来标识Unicode 字符集\nvar s1 string = \"Hello World\"\nvar s2 = \"你好, golang\"\ns3 := \"我爱学 go 语言\"\nfmt.Printf(\"s1: %v\\n\", s1)\nfmt.Printf(\"s2: %v\\n\", s2)\nfmt.Printf(\"s3: %v\\n\", s3)\n\n其他数字类型\n\n\nbyte 字节型\nuint8\n\n\n\nrune Unicode 字符编码\nint32\n\n\n值类型与引用类型golang 中引用类型只有三种slice, map和channel. \n其他的变量类型均属于值类型.\n值类型与引用类型变量的区别就是在函数传参时,是否会产生副本.\n因此诞生了两中传参方式: 值传递与引用传递.\n值传递: 当一个值类型变量传入函数时, 编译器首先复制该变量,产生一个副本,然后将副本传入到函数体内,在函数体内即便对这个副本进行了修改,也不会影响函数体外部的变量数据.\n引用传递: 当使用变量的引用(引用类型的变量名,地址或指针)向函数传参数时, 函数内部对于该变量的修改会影响外部的变量.也就是说,一旦函数体内部修改了这个变量,外部的变量也会随之更改.\n关于值类型与引用类型以及涉及到的内存逃逸分析,会有单独一篇介绍\n零值\n\n\n类型\n零 值\n\n\n\nint, uint8, int32, int64\n0\n\n\nfloat32, float64\n0.0\n\n\nbool\nfalse\n\n\nstring\n&quot;&quot;\n\n\nrune (int32)\n0\n\n\nbyte(uint8)\n0\n\n\ninterface\nnil\n\n\nmap[key]value\nnil\n\n\nslice\nnil\n\n\nchannel\nnil\n\n\n包的导入一般使用绝对路径或者从 github 上导入某个包,而不建议使用 ./方式引入包\n以下为几种导入包的操作.\n// 点操作\nimport (. \"fmt\")\n// 点操作的意义在于当导入了上述包之后, 在使用包中的函数时,不必再加上包名.\n//例如 可以将 fmt.Println() 简写成 Println()\nPrintln(\"hello\")\n\n// 别名操作, 类似于 python 中的 import xxx as X\n// 语法略有不同\nimport f \"fmt\" // import 后面的第一个变量为包的别名, 第二个为具体的包名\nf.Println(\"world\")\n\n包的初始化顺序在 import 包之后, 可以定义全局的常量或者变量.\n若想要使用 init 函数 (在 main 函数执行之前执行的函数,不可被调用), 则预先定义\n在init 函数之后, 可以定义若干函数体.\nGo 程序的启动顺序:go 程序的初始化和执行都起始于 main包. 如果 main 包中还包含了其他的包,则优先在编译时导入,当有多个包导入了同一个包,该包仅被导入一次.如果导入的某个包还包含了其他的包,则优先导入这些包,整体类似于深度优先搜索,然后对各级包中的包级别的常量进行初始化,接着执行 init 函数. 等到所有包都被加载完毕, 开始对 main 包中的包级别常量进行初始化.然后执行 main 包中的 init 函数(如果有的话), 最后执行 main 函数\n","slug":"Golang-tutorial-1","date":"2021-08-29T21:34:48.000Z","categories_index":"Golang","tags_index":"Programming Language","author_index":"Hccc丶"}]