[{"id":"f20d4f48999b3be7c6a4f7d5c95630f9","title":"Golang Tutorial 2","content":"Golang 的 String 详解本章介绍 Go 语言中 string 相关的内容. 包括字符串创建, 修改, 遍历和转换等操作\n\n\nUnicode in Go在 go 中支持 Unicode(UTF-8), 因此字符也称为 Unicode 码点或者runes, 在内存中用 int32 表示.但具体每隔字符占据多少字节是不一样的.一个中文在 go 中占据 3 个字节.\nrune 类型与 byte 类型rune 类型在 go 语言底层实现是一个 int32类型, 它仅仅是一个 int32 的别名. byte 类型底层实现是一个 uint8类型.它也是一个别名\ntype byte &#x3D; uint8\ntype rune &#x3D; int32\n\n零值String 类型的 0 值是一个长度为 0 的字符串&quot;&quot;.因为 go 中 string 是值类型,所以 0 值不是 nil,无法与 nil 进行比较.\n字符串比较一般的字符串比较, 实际是通过在内存中比较字节来实现的. 比如&gt;=, &lt;= , == , !=.\n字符串单个字符的获取字符串单个字符的获取可以通过索引的方式[]来获取,但需要注意的是,在中文字符中,由于一个字符占据三个字节,所以一定要知道在包含中文的字符中,两个字符之间的索引间距不一定是 1,可能是 3\n使用 range 遍历字符串在使用 range 遍历字符串时,以字符为单位进行遍历,也就是说,在返回的 i, 和 v 中,i 的值并不都是规律的\n字符串拼接+ 拼接使用这种拼接方式的缺点在于: 字符串一旦定义就不可更改,有时为了获取最终字符会产生很多的无用字符串,为程序带来 gc 的压力,性能相对较差.\nstr1 :&#x3D; &quot;hello&quot;\nstr2 :&#x3D; &quot;world&quot;\nstr3 :&#x3D; str1 + str22\n\n使用 fmt.Sprintf()此函数内部逻辑较为复杂,判断条件众多, 使用[]byte 实现,性能一般\nfmt.Sprintf(&quot;%d %s&quot;, 2021, &quot;年&quot;)\n\nstrings.Join()strings.Join([]string&#123;&quot;你好&quot;, &quot;golang&quot;&#125;, &quot;-&quot;)\n\n这个函数会根据字符串数组的内容,计算一个拼接之后的总长度,然后申请对应内存大小的内存区域,一个个的填入拼接后的字符串.\n在已有一个字符串数组的情况下,这个效率很搞,但是若本身并没有待拼接的字符串时,创建该数组的代价很大.\nbytes.Buffer()与 strings.Builder()在介绍 bytes.Buffer 和 strings.Builder()之前,先讨论一下 Golang 中的 Pointer 类型, 以及通过 Pointer 对同一块内存数据进行类型转换的方式.\nunsafe.Pointerunsafe.Pointer 代表任意一种类型的指针, 它有四种特殊操作:\nA pointer value of any type can be converted to a Pointer\nA Pointer instance can be converted to a pointer value of any type.\nA uintptr can be converted to a Pointer.\nA Pointer can be converted to a uintptr.\n\n类型转换模式上述的四个操作意思可以简单对应于如下形式\n*T1 &#x3D;&gt; Pointer &#x3D;&gt; *T2\n\n借助Pointer,可以实现一个指针类型的变量到另一个指针类型变量的转换.在这种转换模式中需要保证的是转换后指针类型的T2 的内存 &lt;= T1 的内存. 而且,转换前后两个类型的变量公用同一个内存数据.\nstring 和 []byte 转换var b &#x3D; []byte&#123;&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;&#125; &#x2F;&#x2F; 注意这里是单引号\n&#x2F;&#x2F; 这个步骤就将一个 byte 的 slice 转换成了一个 string 变量,且二者公用同一个快内存数据.\n&#x2F;&#x2F; 一旦 b 被更改,则 s 随之更改\n&#x2F;&#x2F; 因为 string 本身是一个不可变的,所以不能对 s 做任何的修改操作.\ns :&#x3D; *(*string)(unsafe.Pointer(&amp;b))\nfmt.Println(&quot;b: &quot;, b)\nfmt.Println(&quot;s: &quot;, s)\n&#x2F;&#x2F; 结果相同\n&#x2F;&#x2F; 现在修改 b 中的数据\nb[3] &#x3D; &quot;z&quot;\nfmt.Println(&quot;b: &quot;, b)\nfmt.Println(&quot;s: &quot;, s)\n&#x2F;&#x2F; b 与 s 都发生了变化\n&#x2F;&#x2F; 给 s 赋一个新的值, b 不会发生变化,因为 s 是 string 类型,赋新值会创建一个新的 string实例\ns &#x3D; &quot;ABCD&quot;\nfmt.Println(&quot;b: &quot;, b) &#x2F;&#x2F; abcz\nfmt.Println(&quot;s: &quot;, s) &#x2F;&#x2F; ABCD\n\nbytes.Buffer和 strings.Builder 的用法&#x2F;&#x2F; bytes.Buffer\nvar buffer bytes.Buffer\nbuffer.WriteString(&quot;hello&quot;)\nbuffer.WriteString(&quot;,&quot;)\nbuffer.WriteString(&quot;中国&quot;)\nbuffer.WriteString(&quot;!!!&quot;)\nfmt.Println(buffer.String())\n\n&#x2F;&#x2F; strings\nvar builder strings.Builder\nbuilder.WriteString(&quot;ABCD&quot;)\nbuilder.WriteString(&quot;-&quot;)\nbuilder.WriteString(&quot;EFGH&quot;)\nfmt.Println(builder.String())\n\nstrings.Builder()底层实现func (b *Builder) String() string &#123;\n\treturn *(*string)(unsafe.Pointer(&amp;b.buf))\n&#125;\n\n由于是在同一块内存上操作,性能比 bytes.Buffer有所提升\n[]byte, []rune 与 string 的相互转化[]byte 与 string 的相互转化&#x2F;&#x2F; []byte 转为 string\n&#x2F;&#x2F; 第一种借助 unsafe.Pointer 方式转化\nvar bStr &#x3D; []byte&#123;&#39;a&#39;, &#39;b&#39;, &#39;c&#39;&#125;\ns1 :&#x3D; *(*string)(unsafe.Pointer(&amp;bStr))\n&#x2F;&#x2F; 第二种直接用类型转换强转\ns2 &#x3D; string(bStr)\n\n&#x2F;&#x2F; string 转为[]byte\nstr :&#x3D; &quot;这是 string&quot;\nbStr2 :&#x3D; []byte(str)\n&#x2F;&#x2F; 这里的转换会创建一块新内存来对 bStr2 赋值,与 str 独立\n&#x2F;&#x2F; 对 bStr3 的操作,不会影响原本字符串的数据\ns2 :&#x3D; &quot;hello Golang&quot;\nbStr3 :&#x3D; []byte(s2)\nfmt.Println(bStr3)\nbStr3[11] &#x3D; 104\nfmt.Println(s2)\nfmt.Println(string(bStr3))\n\n从上述代码可以得到的结论: 直接使用类型转换时,会产生对原始数据的拷贝,因此对新数据的修改([]byte的修改,因为 string 是不可修改的)不会影响原本的字符串数据.\n换句话说,也正是为了保证 string 不可变的这种一致性,所以才会在进行类型转换时产生数据的拷贝\n[]rune 与 string 的转化​    []rune 与 string 的转化与[]byte 类似,只需要将 byte 换成 rune 即可\n","slug":"Golang-Tutorial-2","date":"2021-09-02T22:10:10.000Z","categories_index":"Golang","tags_index":"Programming Language","author_index":"Hccc丶"},{"id":"940d915bf94905eae8346cbc13db5243","title":"Golang tutorial 1","content":"Golang Tutorial 1Golang Constant Keywordsconst PI float64 &#x3D; 3.1415926\n\n特殊常量: iotaconst (\n\ta &#x3D; iota\t&#x2F;&#x2F; iota 第一次出现时为 0,\n  b\t\t\t\t\t&#x2F;&#x2F; b &#x3D; 1\n  c\t\t\t\t\t&#x2F;&#x2F; c &#x3D; 2\n  d &#x3D; 10\n  e\t\t\t\t\t&#x2F;&#x2F; e &#x3D; 10\n  f\t\t\t\t\t&#x2F;&#x2F; f &#x3D; 10\n)\n\n上述代码中的为 iota 的简单使用, iota 第一次出现时,初值为 0, 后续如果不为新的常量设置初值,则 iota 会递增, 直至遇到一个显式赋值的常量. iota 不在自增.\n典型的 iota 使用案例const Byte &#x3D; 1\nconst (\n  _ &#x3D; iota\n  KB &#x3D; Byte &lt;&lt; (10*iota)\n  MB\n  GB\n  TB\n  PB\n)\n\nGolang variables Keywords在 go 中,所有的变量在定义之后,若没有显式赋值,则为该类型的0 值.\n如果只定义了变量而未在程序中使用,则编译不能通过\n&#x2F;*\n\t第一种变量声明方式,\n\t对于基本类型来说,编译器可以直接进行推断,对于复杂类型,\n*&#x2F;\nvar a int;\na &#x3D; 10\nvar b float32 &#x3D; 10.55\n\n&#x2F;*\n\t第二种变量声明方式, 多用于函数体内\n*&#x2F;\nc :&#x3D; &quot;Hello World&quot;\n\n&#x2F;*\n\t一次性声明多个变量, 在声明变量时,括号内部如果为多行,则不需要等号\n*&#x2F;\nvar (\n\ta int\n  b int\n  c float64\n)\n&#x2F;&#x2F; 或者可以使用如下方式定义多个同种类型的变量\nvar a, b int\n\nGo 也支持对变量的同时(并行)赋值\na, b, c :&#x3D; 1,2, &quot;你好&quot;\n\n特殊变量&#x2F;&#x2F; _ 下划线变量为一个只写变量,当我们有时不需要使用某些函数返回的部分返回值时,可以使用_来抛弃不需要的返回值\nfor _, value :&#x3D; range [1,2,3,4,5] &#123;\n  &#x2F;&#x2F; 在使用 range 关键字时, 会对被遍历的可迭代元素产生两个值,\n  &#x2F;&#x2F; 如果是 slice 或者 array, 则第一个值为元素索引,第二个值\n  &#x2F;&#x2F; 为元素值.\n  &#x2F;&#x2F; 如果被迭代对象为 map, 则第一个值为 key, 第二个值为 value.\n  &#x2F;&#x2F; 如果是字符串, 则第一个值为单个 unicode 字符的起始索引,\n  &#x2F;&#x2F; 因为 unicode 在 go 语言中占据长度不同, range 每次只能遍历一个字符,\n  &#x2F;&#x2F; 所以,在 遍历字符串变量时, 第一个值可能并不连续.\n  fmt.Println(value)\t\n&#125;\n\nGolang Basic Datatype\nbool类型var varName bool &#x3D; true\nif varName &#123;\n  fmt.Println(&quot;true&quot;)\n&#125; else &#123;\n  fmt.Println(&quot;false&quot;)\n&#125;\n数值型在 golang 中, 默认不写类型名时, 浮点数的类型为 float64. 与操作系统的位数有关.\nvar a1 int &#x3D; 100\nvar a2 &#x3D; 200\na3 :&#x3D; 300\nfmt.Println(a1, a2, a3)\n\nvar b1 float32 &#x3D; 12.88\nvar b2 float64 &#x3D; 3.1415926\nvar b3 &#x3D; 8221.441  &#x2F;&#x2F; 默认类型为 float64\nb4 :&#x3D; 741.245312353\n字符串golang 中的字符串是由单个字节连接起来的(英语字符), Go的字节使用 UTF-8编码来标识Unicode 字符集\nvar s1 string &#x3D; &quot;Hello World&quot;\nvar s2 &#x3D; &quot;你好, golang&quot;\ns3 :&#x3D; &quot;我爱学 go 语言&quot;\nfmt.Printf(&quot;s1: %v\\n&quot;, s1)\nfmt.Printf(&quot;s2: %v\\n&quot;, s2)\nfmt.Printf(&quot;s3: %v\\n&quot;, s3)\n其他数字类型\n\n\nbyte 字节型\nuint8\n\n\n\nrune Unicode 字符编码\nint32\n\n\n\n值类型与引用类型golang 中引用类型只有三种slice, map和channel. \n其他的变量类型均属于值类型.\n值类型与引用类型变量的区别就是在函数传参时,是否会产生副本.\n因此诞生了两中传参方式: 值传递与引用传递.\n值传递: 当一个值类型变量传入函数时, 编译器首先复制该变量,产生一个副本,然后将副本传入到函数体内,在函数体内即便对这个副本进行了修改,也不会影响函数体外部的变量数据.\n引用传递: 当使用变量的引用(引用类型的变量名,地址或指针)向函数传参数时, 函数内部对于该变量的修改会影响外部的变量.也就是说,一旦函数体内部修改了这个变量,外部的变量也会随之更改.\n关于值类型与引用类型以及涉及到的内存逃逸分析,会有单独一篇介绍\n\n零值\n\n\n类型\n零 值\n\n\n\nint, uint8, int32, int64\n0\n\n\nfloat32, float64\n0.0\n\n\nbool\nfalse\n\n\nstring\n&quot;&quot;\n\n\nrune (int32)\n0\n\n\nbyte(uint8)\n0\n\n\ninterface\nnil\n\n\nmap[key]value\nnil\n\n\nslice\nnil\n\n\nchannel\nnil\n\n\n\n包的导入一般使用绝对路径或者从 github 上导入某个包,而不建议使用 ./方式引入包\n以下为几种导入包的操作.\n&#x2F;&#x2F; 点操作\nimport (. &quot;fmt&quot;)\n&#x2F;&#x2F; 点操作的意义在于当导入了上述包之后, 在使用包中的函数时,不必再加上包名.\n&#x2F;&#x2F;例如 可以将 fmt.Println() 简写成 Println()\nPrintln(&quot;hello&quot;)\n\n&#x2F;&#x2F; 别名操作, 类似于 python 中的 import xxx as X\n&#x2F;&#x2F; 语法略有不同\nimport f &quot;fmt&quot; &#x2F;&#x2F; import 后面的第一个变量为包的别名, 第二个为具体的包名\nf.Println(&quot;world&quot;)\n\n\n包的初始化顺序在 import 包之后, 可以定义全局的常量或者变量.\n若想要使用 init 函数 (在 main 函数执行之前执行的函数,不可被调用), 则预先定义\n在init 函数之后, 可以定义若干函数体.\n\n\n\nGo 程序的启动顺序:go 程序的初始化和执行都起始于 main包. 如果 main 包中还包含了其他的包,则优先在编译时导入,当有多个包导入了同一个包,该包仅被导入一次.如果导入的某个包还包含了其他的包,则优先导入这些包,整体类似于深度优先搜索,然后对各级包中的包级别的常量进行初始化,接着执行 init 函数. 等到所有包都被加载完毕, 开始对 main 包中的包级别常量进行初始化.然后执行 main 包中的 init 函数(如果有的话), 最后执行 main 函数\n\n\n","slug":"Golang-tutorial-1","date":"2021-08-29T21:34:48.000Z","categories_index":"Golang","tags_index":"Programming Language","author_index":"Hccc丶"}]