[{"id":"ed56a0be6c67a53488e6ffd0f75904e2","title":"Golang Tutorial 4","content":"Golang Tutorial 4切片(slice)Golang 中的切片是对数组一个连续片段的引用, 因此是引用类型. 这个连续的片段可以是整个数组,也可以是由开发者指定的开始和结束索引限定的一段连续片段. 从集合的角度来看,若数组是一个元素集合,则切片就是它的一系列非空子集.\n既然是数组的引用,那么切片本身也具备数组的一些性质.另外,切片同时也具备一些数组不具备的特质,比如可以向切片中增加元素.\n切片同时提供了可以计算切片容量的函数 cap(), 如果切片是由数组创建的, 计算方法是从切片的起始元素到数组末尾的长度.\n创建切片的方式\nmake创建&#x2F;&#x2F; 创建格式: make(type, len[, cap])\n&#x2F;&#x2F; 创建一个长度为 5, 容量为 10 的切片\n&#x2F;&#x2F; 切片容量代表的是当切片元素达到 5 时, 继续往后最多可添加的元素个数\n&#x2F;&#x2F; 当再添加五个元素后,切片容量达到最大,此时若再向其中添加元素,则需要重新构建\n&#x2F;&#x2F; 新的切片.因此, 在一些结构体中,可能需要使用指针接收者来指向原始的切片数据\ns1 :&#x3D; make([]int, 5, 10)\n\n&#x2F;&#x2F; 切片的遍历\nfor idx, value :&#x3D; range s1 &#123;\n  fmt.Println(idx, value)\n&#125;\n显式初始化var sli1 &#x3D; []int&#123;1,2,3,4,4&#125;\nsli2 :&#x3D; []string&#123;&quot;zhangsan&quot;, &quot;lisi&quot;, &quot;wangwu&quot;&#125;\n从数组中创建arr1 :&#x3D; [...]int&#123;1,2,3,4,5&#125;\nsli3 :&#x3D; arr1[1:3] &#x2F;&#x2F; 方括号中的索引是包含左边不包含右边的\n&#x2F;&#x2F; sli3 的输出结果是 2 3\n\ncopy函数利用 copy 函数可以对一个已有的切片进行拷贝,具体语法如下\nrst :&#x3D; make([]string, 5, 10)\ntemp :&#x3D; []string&#123;&quot;Beijing&quot;, &quot;London&quot;, &quot;Glasgow&quot;&#125;\n&#x2F;&#x2F; copy 函数会将后续参数中的元素全部复制到第一个参数的切片中\n&#x2F;&#x2F; copy(dest, src) &#x2F;&#x2F; 将 src 中的元素拷贝到 dest 中\ncopy(rst, temp)\n\nappend 函数append 函数会将0 个或者多个具有相同类型的元素追加到已有的切片中,若超出了切片的容量时, 切片会发生扩容, append 会重新分配一块新的内存区域来存放整个新的切片.此时旧的切片将保持扩容到最大容量时的数据. append 函数总是成功返回的,除非内存消耗殆尽.\ns1 :&#x3D; make([]int, 2, 4)\nvar s2 []int\nfmt.Printf(&quot;%p \\n&quot;, s2)\t&#x2F;&#x2F;打印初始的s2 地址,由于未初始化,并未分配实际的内存地址\nfor i :&#x3D; 0; i &lt; 5; i++ &#123;\t&#x2F;&#x2F; 此处设置 5 是为了测试当容量超出原始 slice 的容量时,看append 函数是否会对 slice 进行扩容并分配新的内存空间给新变量\n  if i &gt;&#x3D; len(s1) &amp;&amp; i &lt; cap(s1) &#123;\n    fmt.Println(&quot;长度不足,在 slice 容量内扩容&quot;)\n    s1 &#x3D; append(s1, i)\n    fmt.Printf(&quot;%p %v \\n&quot;, s1, s1[i])\n  &#125; else if i &lt; len(s1) &#123;\n    fmt.Println(&quot;长度足够, 直接对 slice 元素赋值&quot;)\n    s1[i] &#x3D; i\n    fmt.Printf(&quot;%p %v \\n&quot;, s1, s1[i])\n  &#125; else &#123;\n    fmt.Println(&quot;元素个数已超出原始 slice 容量, append 函数重新分配内存空间给新的 slice&quot;)\n    s2 &#x3D; append(s1, i)\n    fmt.Printf(&quot;%p %v\\n&quot;, s2, s2[i])\n    fmt.Printf(&quot;len(s2)&#x3D;%v cap(s2)&#x3D;%v \\n&quot;, len(s2), cap(s2))\n  &#125;\n&#125;\nfmt.Printf(&quot;%p %v\\n&quot;, s1, s1)\nfmt.Printf(&quot;%p %v\\n&quot;, s2, s2)\n\nslice 的扩容规则根据上述代码的输出结果,最终 cap=4 的 s1 在容量不足进行扩充后,s2 容量为 8.因此扩容规则为 double 原始 slice 的容量 capacity.\nnew 函数和 make 函数的区别new 函数会分配指定类型的指针给变量. 多用于结构体类型和数组等值类型变量, 相当于&amp;T&#123;&#125;,其中 T 可以是[5]int, [6]string以及 &amp;Student&#123;&#125;等自定义类型.\nnew 函数创建的指针变量值为 0x0, 若为 silce, 则 len=0, cap=0. 变量指向的实际 slice 为一个nil.而 slice 的 nil 输出为一个[].\nmake 会初始化一个slice 变量, 并分配实际内存, 创建对应类型的初值. 在不指定 cap 的时候,cap 会与 len 相等.\ntemp1 :&#x3D; new([]int)\nfmt.Printf(&quot;%p %v %v %v\\n&quot;, *temp1, *temp1, len(*temp1), cap(*temp1))\nfmt.Println(*temp1 &#x3D;&#x3D; nil)\ntemp2 :&#x3D; make([]int, 5)\nfmt.Printf(&quot;%p %v %v %v \\n&quot;, temp2, temp2, len(temp2), cap(temp2))\n\n可以根据上述代码自行检验结果.\n","slug":"Golang-Tutorial-4","date":"2021-09-05T22:06:48.000Z","categories_index":"Golang","tags_index":"Programming Language","author_index":"Hccc丶"},{"id":"3983d1b06f9cc59a424cf4b8b973001f","title":"Golang Tutorial 3","content":"Golang Tutorial 3数组(Array)在 golang 中,数组是值类型变量,当作为参数传递时,会发生值拷贝,在函数体内部对数组进行修改后,并不会影响函数体外的数据\n作为强类型语言, Golang 中的数组元素必须都是相同类型,此点与 python 的 list 有所区别\n同时,作为值类型的变量类型, go 提供了 new 关键字来为其分配指针.\nGolang 中声明数组的几种方式需要注意的是,声明数组时必须指定数组元素的个数,或者在方括号[]内使用...由编译器推断具体的数组元素个数\n直接声明var arr [5]int\n&#x2F;&#x2F; 直接声明而不初始化时, 编译器默认为数组分配 0 值\n\n这种声明方式创建的 arr 变量类型是[5]int 类型, 当直接使用 arr 传参时, 会对 arr 进行值拷贝.\n初始化显式的为数组元素指定值,可以部分指定,余下的部分自动赋值 0 值\nvar arr1 &#x3D; [10]int&#123;1,2,3,4&#125;\n\n使用指定索引的方式进行初始化,未被指定的部分赋值对应类型的 0 值\nvar arr2 &#x3D; [5]int&#123;0:1, 3:5&#125;\n\n使用...指定数组,编译器自动推断数组元素个数, 这种指定方式必须带有初始化,否则报错.\nvar arr3 &#x3D; [...]int&#123;1,3,4,5,6&#125;\n\n多维数组二维数组func main()&#123;\n\tvar array &#x3D; [3][2]string&#123;\n    &#123;&quot;中国&quot;, &quot;北京&quot;&#125;,\n    &#123;&quot;美国&quot;, &quot;华盛顿&quot;&#125;,\n\t\t&#123;&quot;英国&quot;, &quot;伦敦&quot;&#125;,\n\t&#125;\n\n\t&#x2F;&#x2F; 使用两种方式遍历数组\n\tfor _, value :&#x3D; range array &#123;\n\t\tvar builder strings.Builder\n\t\tfor i :&#x3D; 0; i &lt; len(value); i++ &#123;\n      &#x2F;&#x2F; 练习使用 strings.Builder 来拼接字符串\n\t\t\tbuilder.WriteString(value[i])\n\t\t\tbuilder.WriteString(&quot;-&quot;)\n\t\t&#125;\n\t\tfmt.Println(builder.String())\n\t&#125;\n&#125;\n\n需要注意的是使用 range 方式遍历可迭代的类型时, value 都是可迭代变量中元素的副本,对他的修改不会改变原始数据\n数组可变因数组支持对其内部元素的更改, 因此称其为可变的\nvar arr1 [5]int\narr1[0] &#x3D; 1\n\n","slug":"Golang-Tutorial-3","date":"2021-09-03T07:30:17.000Z","categories_index":"Golang","tags_index":"Programming Language","author_index":"Hccc丶"},{"id":"f20d4f48999b3be7c6a4f7d5c95630f9","title":"Golang Tutorial 2","content":"Golang 的 String 详解本章介绍 Go 语言中 string 相关的内容. 包括字符串创建, 修改, 遍历和转换等操作\n\n\nUnicode in Go在 go 中支持 Unicode(UTF-8), 因此字符也称为 Unicode 码点或者runes, 在内存中用 int32 表示.但具体每隔字符占据多少字节是不一样的.一个中文在 go 中占据 3 个字节.\nrune 类型与 byte 类型rune 类型在 go 语言底层实现是一个 int32类型, 它仅仅是一个 int32 的别名. byte 类型底层实现是一个 uint8类型.它也是一个别名\ntype byte &#x3D; uint8\ntype rune &#x3D; int32\n\n零值String 类型的 0 值是一个长度为 0 的字符串&quot;&quot;.因为 go 中 string 是值类型,所以 0 值不是 nil,无法与 nil 进行比较.\n字符串比较一般的字符串比较, 实际是通过在内存中比较字节来实现的. 比如&gt;=, &lt;= , == , !=.\n字符串单个字符的获取字符串单个字符的获取可以通过索引的方式[]来获取,但需要注意的是,在中文字符中,由于一个字符占据三个字节,所以一定要知道在包含中文的字符中,两个字符之间的索引间距不一定是 1,可能是 3\n使用 range 遍历字符串在使用 range 遍历字符串时,以字符为单位进行遍历,也就是说,在返回的 i, 和 v 中,i 的值并不都是规律的\n字符串拼接+ 拼接使用这种拼接方式的缺点在于: 字符串一旦定义就不可更改,有时为了获取最终字符会产生很多的无用字符串,为程序带来 gc 的压力,性能相对较差.\nstr1 :&#x3D; &quot;hello&quot;\nstr2 :&#x3D; &quot;world&quot;\nstr3 :&#x3D; str1 + str22\n\n使用 fmt.Sprintf()此函数内部逻辑较为复杂,判断条件众多, 使用[]byte 实现,性能一般\nfmt.Sprintf(&quot;%d %s&quot;, 2021, &quot;年&quot;)\n\nstrings.Join()strings.Join([]string&#123;&quot;你好&quot;, &quot;golang&quot;&#125;, &quot;-&quot;)\n\n此函数会根据字符串切片的内容,计算一个拼接之后的总长度,然后申请对应内存大小的内存区域,一个个的填入拼接后的字符串.\n在已有一个字符串切片的情况下,这个效率很搞,但是若本身并没有待拼接的字符串时,创建该数组的代价很大.\nJoin 函数在拼接字符串时,会在每个切片元素之间插入一个空字符串&quot;&quot;, 然后根据第二个参数指定的字符串进行替换.\nvar arrKeyValue &#x3D; [5]string&#123;2: &quot;Chris&quot;, 4: &quot;Ron&quot;&#125;\nfmt.Println(strings.Join(arrKeyValue[:], &quot;,&quot;))\n\n上述代码利用指定数组元素索引的方式初始化了数组,然后利用切片特性将数组转化为切片.输出结果为\n,,Chris,,Ron \n&#x2F;&#x2F; Ron 前面一个逗号是 Join 函数添加的,因为要在两个字符之间添加一个空字符串\n&#x2F;&#x2F; Chris 前的两个逗号和后面的第一个逗号是原本初始化数组时默认给定的字符串 0 值\n&#x2F;&#x2F; 在Join 函数内统一将 &quot;&quot; 替换为了指定的字符串\n\nbytes.Buffer()与 strings.Builder()在介绍 bytes.Buffer 和 strings.Builder()之前,先讨论一下 Golang 中的 Pointer 类型, 以及通过 Pointer 对同一块内存数据进行类型转换的方式.\nunsafe.Pointerunsafe.Pointer 代表任意一种类型的指针, 它有四种特殊操作:\nA pointer value of any type can be converted to a Pointer\nA Pointer instance can be converted to a pointer value of any type.\nA uintptr can be converted to a Pointer.\nA Pointer can be converted to a uintptr.\n\n类型转换模式上述的四个操作意思可以简单对应于如下形式\n*T1 &#x3D;&gt; Pointer &#x3D;&gt; *T2\n\n借助Pointer,可以实现一个指针类型的变量到另一个指针类型变量的转换.在这种转换模式中需要保证的是转换后指针类型的T2 的内存 &lt;= T1 的内存. 而且,转换前后两个类型的变量公用同一个内存数据.\nstring 和 []byte 转换var b &#x3D; []byte&#123;&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;&#125; &#x2F;&#x2F; 注意这里是单引号\n&#x2F;&#x2F; 这个步骤就将一个 byte 的 slice 转换成了一个 string 变量,且二者公用同一个快内存数据.\n&#x2F;&#x2F; 一旦 b 被更改,则 s 随之更改\n&#x2F;&#x2F; 因为 string 本身是一个不可变的,所以不能对 s 做任何的修改操作.\ns :&#x3D; *(*string)(unsafe.Pointer(&amp;b))\nfmt.Println(&quot;b: &quot;, b)\nfmt.Println(&quot;s: &quot;, s)\n&#x2F;&#x2F; 结果相同\n&#x2F;&#x2F; 现在修改 b 中的数据\nb[3] &#x3D; &quot;z&quot;\nfmt.Println(&quot;b: &quot;, b)\nfmt.Println(&quot;s: &quot;, s)\n&#x2F;&#x2F; b 与 s 都发生了变化\n&#x2F;&#x2F; 给 s 赋一个新的值, b 不会发生变化,因为 s 是 string 类型,赋新值会创建一个新的 string实例\ns &#x3D; &quot;ABCD&quot;\nfmt.Println(&quot;b: &quot;, b) &#x2F;&#x2F; abcz\nfmt.Println(&quot;s: &quot;, s) &#x2F;&#x2F; ABCD\n\nbytes.Buffer和 strings.Builder 的用法&#x2F;&#x2F; bytes.Buffer\nvar buffer bytes.Buffer\nbuffer.WriteString(&quot;hello&quot;)\nbuffer.WriteString(&quot;,&quot;)\nbuffer.WriteString(&quot;中国&quot;)\nbuffer.WriteString(&quot;!!!&quot;)\nfmt.Println(buffer.String())\n\n&#x2F;&#x2F; strings\nvar builder strings.Builder\nbuilder.WriteString(&quot;ABCD&quot;)\nbuilder.WriteString(&quot;-&quot;)\nbuilder.WriteString(&quot;EFGH&quot;)\nfmt.Println(builder.String())\n\nstrings.Builder()底层实现func (b *Builder) String() string &#123;\n\treturn *(*string)(unsafe.Pointer(&amp;b.buf))\n&#125;\n\n由于是在同一块内存上操作,性能比 bytes.Buffer有所提升\n[]byte, []rune 与 string 的相互转化[]byte 与 string 的相互转化&#x2F;&#x2F; []byte 转为 string\n&#x2F;&#x2F; 第一种借助 unsafe.Pointer 方式转化\nvar bStr &#x3D; []byte&#123;&#39;a&#39;, &#39;b&#39;, &#39;c&#39;&#125;\ns1 :&#x3D; *(*string)(unsafe.Pointer(&amp;bStr))\n&#x2F;&#x2F; 第二种直接用类型转换强转\ns2 &#x3D; string(bStr)\n\n&#x2F;&#x2F; string 转为[]byte\nstr :&#x3D; &quot;这是 string&quot;\nbStr2 :&#x3D; []byte(str)\n&#x2F;&#x2F; 这里的转换会创建一块新内存来对 bStr2 赋值,与 str 独立\n&#x2F;&#x2F; 对 bStr3 的操作,不会影响原本字符串的数据\ns2 :&#x3D; &quot;hello Golang&quot;\nbStr3 :&#x3D; []byte(s2)\nfmt.Println(bStr3)\nbStr3[11] &#x3D; 104\nfmt.Println(s2)\nfmt.Println(string(bStr3))\n\n从上述代码可以得到的结论: 直接使用类型转换时,会产生对原始数据的拷贝,因此对新数据的修改([]byte的修改,因为 string 是不可修改的)不会影响原本的字符串数据.\n换句话说,也正是为了保证 string 不可变的这种一致性,所以才会在进行类型转换时产生数据的拷贝\n[]rune 与 string 的转化​    []rune 与 string 的转化与[]byte 类似,只需要将 byte 换成 rune 即可\n","slug":"Golang-Tutorial-2","date":"2021-09-02T22:10:10.000Z","categories_index":"Golang","tags_index":"Programming Language","author_index":"Hccc丶"},{"id":"940d915bf94905eae8346cbc13db5243","title":"Golang tutorial 1","content":"Golang Tutorial 1Golang Constant Keywordsconst PI float64 &#x3D; 3.1415926\n\n特殊常量: iotaconst (\n\ta &#x3D; iota\t&#x2F;&#x2F; iota 第一次出现时为 0,\n  b\t\t\t\t\t&#x2F;&#x2F; b &#x3D; 1\n  c\t\t\t\t\t&#x2F;&#x2F; c &#x3D; 2\n  d &#x3D; 10\n  e\t\t\t\t\t&#x2F;&#x2F; e &#x3D; 10\n  f\t\t\t\t\t&#x2F;&#x2F; f &#x3D; 10\n)\n\n上述代码中的为 iota 的简单使用, iota 第一次出现时,初值为 0, 后续如果不为新的常量设置初值,则 iota 会递增, 直至遇到一个显式赋值的常量. iota 不在自增.\n典型的 iota 使用案例const Byte &#x3D; 1\nconst (\n  _ &#x3D; iota\n  KB &#x3D; Byte &lt;&lt; (10*iota)\n  MB\n  GB\n  TB\n  PB\n)\n\nGolang variables Keywords在 go 中,所有的变量在定义之后,若没有显式赋值,则为该类型的0 值.\n如果只定义了变量而未在程序中使用,则编译不能通过\n&#x2F;*\n\t第一种变量声明方式,\n\t对于基本类型来说,编译器可以直接进行推断,对于复杂类型,\n*&#x2F;\nvar a int;\na &#x3D; 10\nvar b float32 &#x3D; 10.55\n\n&#x2F;*\n\t第二种变量声明方式, 多用于函数体内\n*&#x2F;\nc :&#x3D; &quot;Hello World&quot;\n\n&#x2F;*\n\t一次性声明多个变量, 在声明变量时,括号内部如果为多行,则不需要等号\n*&#x2F;\nvar (\n\ta int\n  b int\n  c float64\n)\n&#x2F;&#x2F; 或者可以使用如下方式定义多个同种类型的变量\nvar a, b int\n\nGo 也支持对变量的同时(并行)赋值\na, b, c :&#x3D; 1,2, &quot;你好&quot;\n\n特殊变量&#x2F;&#x2F; _ 下划线变量为一个只写变量,当我们有时不需要使用某些函数返回的部分返回值时,可以使用_来抛弃不需要的返回值\nfor _, value :&#x3D; range [1,2,3,4,5] &#123;\n  &#x2F;&#x2F; 在使用 range 关键字时, 会对被遍历的可迭代元素产生两个值,\n  &#x2F;&#x2F; 如果是 slice 或者 array, 则第一个值为元素索引,第二个值\n  &#x2F;&#x2F; 为元素值.\n  &#x2F;&#x2F; 如果被迭代对象为 map, 则第一个值为 key, 第二个值为 value.\n  &#x2F;&#x2F; 如果是字符串, 则第一个值为单个 unicode 字符的起始索引,\n  &#x2F;&#x2F; 因为 unicode 在 go 语言中占据长度不同, range 每次只能遍历一个字符,\n  &#x2F;&#x2F; 所以,在 遍历字符串变量时, 第一个值可能并不连续.\n  fmt.Println(value)\t\n&#125;\n\nGolang Basic Datatype\nbool类型var varName bool &#x3D; true\nif varName &#123;\n  fmt.Println(&quot;true&quot;)\n&#125; else &#123;\n  fmt.Println(&quot;false&quot;)\n&#125;\n数值型在 golang 中, 默认不写类型名时, 浮点数的类型为 float64. 与操作系统的位数有关.\nvar a1 int &#x3D; 100\nvar a2 &#x3D; 200\na3 :&#x3D; 300\nfmt.Println(a1, a2, a3)\n\nvar b1 float32 &#x3D; 12.88\nvar b2 float64 &#x3D; 3.1415926\nvar b3 &#x3D; 8221.441  &#x2F;&#x2F; 默认类型为 float64\nb4 :&#x3D; 741.245312353\n字符串golang 中的字符串是由单个字节连接起来的(英语字符), Go的字节使用 UTF-8编码来标识Unicode 字符集\nvar s1 string &#x3D; &quot;Hello World&quot;\nvar s2 &#x3D; &quot;你好, golang&quot;\ns3 :&#x3D; &quot;我爱学 go 语言&quot;\nfmt.Printf(&quot;s1: %v\\n&quot;, s1)\nfmt.Printf(&quot;s2: %v\\n&quot;, s2)\nfmt.Printf(&quot;s3: %v\\n&quot;, s3)\n其他数字类型\n\n\nbyte 字节型\nuint8\n\n\n\nrune Unicode 字符编码\nint32\n\n\n\n值类型与引用类型golang 中引用类型只有三种slice, map和channel. \n其他的变量类型均属于值类型.\n值类型与引用类型变量的区别就是在函数传参时,是否会产生副本.\n因此诞生了两中传参方式: 值传递与引用传递.\n值传递: 当一个值类型变量传入函数时, 编译器首先复制该变量,产生一个副本,然后将副本传入到函数体内,在函数体内即便对这个副本进行了修改,也不会影响函数体外部的变量数据.\n引用传递: 当使用变量的引用(引用类型的变量名,地址或指针)向函数传参数时, 函数内部对于该变量的修改会影响外部的变量.也就是说,一旦函数体内部修改了这个变量,外部的变量也会随之更改.\n关于值类型与引用类型以及涉及到的内存逃逸分析,会有单独一篇介绍\n\n零值\n\n\n类型\n零 值\n\n\n\nint, uint8, int32, int64\n0\n\n\nfloat32, float64\n0.0\n\n\nbool\nfalse\n\n\nstring\n&quot;&quot;\n\n\nrune (int32)\n0\n\n\nbyte(uint8)\n0\n\n\ninterface\nnil\n\n\nmap[key]value\nnil\n\n\nslice\nnil\n\n\nchannel\nnil\n\n\n\n包的导入一般使用绝对路径或者从 github 上导入某个包,而不建议使用 ./方式引入包\n以下为几种导入包的操作.\n&#x2F;&#x2F; 点操作\nimport (. &quot;fmt&quot;)\n&#x2F;&#x2F; 点操作的意义在于当导入了上述包之后, 在使用包中的函数时,不必再加上包名.\n&#x2F;&#x2F;例如 可以将 fmt.Println() 简写成 Println()\nPrintln(&quot;hello&quot;)\n\n&#x2F;&#x2F; 别名操作, 类似于 python 中的 import xxx as X\n&#x2F;&#x2F; 语法略有不同\nimport f &quot;fmt&quot; &#x2F;&#x2F; import 后面的第一个变量为包的别名, 第二个为具体的包名\nf.Println(&quot;world&quot;)\n\n\n包的初始化顺序在 import 包之后, 可以定义全局的常量或者变量.\n若想要使用 init 函数 (在 main 函数执行之前执行的函数,不可被调用), 则预先定义\n在init 函数之后, 可以定义若干函数体.\n\n\n\nGo 程序的启动顺序:go 程序的初始化和执行都起始于 main包. 如果 main 包中还包含了其他的包,则优先在编译时导入,当有多个包导入了同一个包,该包仅被导入一次.如果导入的某个包还包含了其他的包,则优先导入这些包,整体类似于深度优先搜索,然后对各级包中的包级别的常量进行初始化,接着执行 init 函数. 等到所有包都被加载完毕, 开始对 main 包中的包级别常量进行初始化.然后执行 main 包中的 init 函数(如果有的话), 最后执行 main 函数\n\n\n","slug":"Golang-tutorial-1","date":"2021-08-29T21:34:48.000Z","categories_index":"Golang","tags_index":"Programming Language","author_index":"Hccc丶"}]