[{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2021-09-02T07:12:09.909Z","categories_index":"","tags_index":"","author_index":"Hccc丶"},{"id":"940d915bf94905eae8346cbc13db5243","title":"Golang tutorial 1","content":"Golang Tutorial 1Golang Constant Keywordsconst PI float64 &#x3D; 3.1415926\n\n特殊常量: iotaconst (\n\ta &#x3D; iota\t&#x2F;&#x2F; iota 第一次出现时为 0,\n  b\t\t\t\t\t&#x2F;&#x2F; b &#x3D; 1\n  c\t\t\t\t\t&#x2F;&#x2F; c &#x3D; 2\n  d &#x3D; 10\n  e\t\t\t\t\t&#x2F;&#x2F; e &#x3D; 10\n  f\t\t\t\t\t&#x2F;&#x2F; f &#x3D; 10\n)\n\n上述代码中的为 iota 的简单使用, iota 第一次出现时,初值为 0, 后续如果不为新的常量设置初值,则 iota 会递增, 直至遇到一个显式赋值的常量. iota 不在自增.\n典型的 iota 使用案例const Byte &#x3D; 1\nconst (\n  _ &#x3D; iota\n  KB &#x3D; Byte &lt;&lt; (10*iota)\n  MB\n  GB\n  TB\n  PB\n)\n\nGolang variables Keywords在 go 中,所有的变量在定义之后,若没有显式赋值,则为该类型的0 值.\n如果只定义了变量而未在程序中使用,则编译不能通过\n&#x2F;*\n\t第一种变量声明方式,\n\t对于基本类型来说,编译器可以直接进行推断,对于复杂类型,\n*&#x2F;\nvar a int;\na &#x3D; 10\nvar b float32 &#x3D; 10.55\n\n&#x2F;*\n\t第二种变量声明方式, 多用于函数体内\n*&#x2F;\nc :&#x3D; &quot;Hello World&quot;\n\n&#x2F;*\n\t一次性声明多个变量, 在声明变量时,括号内部如果为多行,则不需要等号\n*&#x2F;\nvar (\n\ta int\n  b int\n  c float64\n)\n&#x2F;&#x2F; 或者可以使用如下方式定义多个同种类型的变量\nvar a, b int\n\nGo 也支持对变量的同时(并行)赋值\na, b, c :&#x3D; 1,2, &quot;你好&quot;\n\n特殊变量&#x2F;&#x2F; _ 下划线变量为一个只写变量,当我们有时不需要使用某些函数返回的部分返回值时,可以使用_来抛弃不需要的返回值\nfor _, value :&#x3D; range [1,2,3,4,5] &#123;\n  &#x2F;&#x2F; 在使用 range 关键字时, 会对被遍历的可迭代元素产生两个值,\n  &#x2F;&#x2F; 如果是 slice 或者 array, 则第一个值为元素索引,第二个值\n  &#x2F;&#x2F; 为元素值.\n  &#x2F;&#x2F; 如果被迭代对象为 map, 则第一个值为 key, 第二个值为 value.\n  &#x2F;&#x2F; 如果是字符串, 则第一个值为单个 unicode 字符的起始索引,\n  &#x2F;&#x2F; 因为 unicode 在 go 语言中占据长度不同, range 每次只能遍历一个字符,\n  &#x2F;&#x2F; 所以,在 遍历字符串变量时, 第一个值可能并不连续.\n  fmt.Println(value)\t\n&#125;\n\nGolang Basic Datatype\nbool类型var varName bool &#x3D; true\nif varName &#123;\n  fmt.Println(&quot;true&quot;)\n&#125; else &#123;\n  fmt.Println(&quot;false&quot;)\n&#125;\n数值型在 golang 中, 默认不写类型名时, 浮点数的类型为 float64. 与操作系统的位数有关.\nvar a1 int &#x3D; 100\nvar a2 &#x3D; 200\na3 :&#x3D; 300\nfmt.Println(a1, a2, a3)\n\nvar b1 float32 &#x3D; 12.88\nvar b2 float64 &#x3D; 3.1415926\nvar b3 &#x3D; 8221.441  &#x2F;&#x2F; 默认类型为 float64\nb4 :&#x3D; 741.245312353\n字符串golang 中的字符串是由单个字节连接起来的(英语字符), Go的字节使用 UTF-8编码来标识Unicode 字符集\nvar s1 string &#x3D; &quot;Hello World&quot;\nvar s2 &#x3D; &quot;你好, golang&quot;\ns3 :&#x3D; &quot;我爱学 go 语言&quot;\nfmt.Printf(&quot;s1: %v\\n&quot;, s1)\nfmt.Printf(&quot;s2: %v\\n&quot;, s2)\nfmt.Printf(&quot;s3: %v\\n&quot;, s3)\n其他数字类型\n\n\nbyte 字节型\nuint8\n\n\n\nrune Unicode 字符编码\nint32\n\n\n\n值类型与引用类型golang 中引用类型只有三种slice, map和channel. \n其他的变量类型均属于值类型.\n值类型与引用类型变量的区别就是在函数传参时,是否会产生副本.\n因此诞生了两中传参方式: 值传递与引用传递.\n值传递: 当一个值类型变量传入函数时, 编译器首先复制该变量,产生一个副本,然后将副本传入到函数体内,在函数体内即便对这个副本进行了修改,也不会影响函数体外部的变量数据.\n引用传递: 当使用变量的引用(引用类型的变量名,地址或指针)向函数传参数时, 函数内部对于该变量的修改会影响外部的变量.也就是说,一旦函数体内部修改了这个变量,外部的变量也会随之更改.\n关于值类型与引用类型以及涉及到的内存逃逸分析,会有单独一篇介绍\n\n零值\n\n\n类型\n零 值\n\n\n\nint, uint8, int32, int64\n0\n\n\nfloat32, float64\n0.0\n\n\nbool\nfalse\n\n\nstring\n&quot;&quot;\n\n\nrune (int32)\n0\n\n\nbyte(uint8)\n0\n\n\ninterface\nnil\n\n\nmap[key]value\nnil\n\n\nslice\nnil\n\n\nchannel\nnil\n\n\n\n包的导入一般使用绝对路径或者从 github 上导入某个包,而不建议使用 ./方式引入包\n以下为几种导入包的操作.\n&#x2F;&#x2F; 点操作\nimport (. &quot;fmt&quot;)\n&#x2F;&#x2F; 点操作的意义在于当导入了上述包之后, 在使用包中的函数时,不必再加上包名.\n&#x2F;&#x2F;例如 可以将 fmt.Println() 简写成 Println()\nPrintln(&quot;hello&quot;)\n\n&#x2F;&#x2F; 别名操作, 类似于 python 中的 import xxx as X\n&#x2F;&#x2F; 语法略有不同\nimport f &quot;fmt&quot; &#x2F;&#x2F; import 后面的第一个变量为包的别名, 第二个为具体的包名\nf.Println(&quot;world&quot;)\n\n\n包的初始化顺序在 import 包之后, 可以定义全局的常量或者变量.\n若想要使用 init 函数 (在 main 函数执行之前执行的函数,不可被调用), 则预先定义\n在init 函数之后, 可以定义若干函数体.\n\n\n\nGo 程序的启动顺序:go 程序的初始化和执行都起始于 main包. 如果 main 包中还包含了其他的包,则优先在编译时导入,当有多个包导入了同一个包,该包仅被导入一次.如果导入的某个包还包含了其他的包,则优先导入这些包,整体类似于深度优先搜索,然后对各级包中的包级别的常量进行初始化,接着执行 init 函数. 等到所有包都被加载完毕, 开始对 main 包中的包级别常量进行初始化.然后执行 main 包中的 init 函数(如果有的话), 最后执行 main 函数\n\n\n","slug":"Golang-tutorial-1","date":"2021-08-29T21:34:48.000Z","categories_index":"Golang","tags_index":"Programming Language","author_index":"Hccc丶"}]