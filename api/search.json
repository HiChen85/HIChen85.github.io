[{"id":"b9ad58d220db9597427a33bc2b1eea6a","title":"Golang Tutorial 9","content":"Golang Tutorial 9 Function函数的可变参数在 Go 语言中, 函数可以指定一个不定长参数来接收多个同类型参数. 但是这个参数需要放在其他固定参数的最后. 本质上这个可变参数的实现是通过 slice. 所以在接收参数后也应当以切片对待\n可变参数的定义func A(a int, b float64, items ...interface&#123;&#125;) &#123;\n  for i, v := items &#123;\n    // do something\n  &#125;\n&#125;\n\n在上述代码中,使用...来标识一个形参是可变参数. 在函数体内部,这个变量被当做所有可变参数的一个 slice. 可以直接对这个变量进行 for-range 迭代.\n可变参数的传入\n直接传入多个参数.\nfmt.Println()函数可一次性打印多个变量.就是定义了一个可以接收可变参数的空接口变量. 其函数签名如下\nfunc fmt.Println(a ...interface&#123;&#125;) (n int, err error)\n传入一个切片\n可以向定义了可变参数的函数中传入一个切片\nfunc PrintArray(array ...int) &#123;\n\tfor i, v := range array &#123;\n\t\tfmt.Println(i, v)\n\t&#125;\n&#125;\narr1 := []int&#123;1,2,3,4,5&#125;\nPrintArray(arr...)\n\n高阶函数所谓高阶函数是指返回值为函数的函数或者接收函数作为参数的函数.\n将函数作为参数的高阶函数, 最常见的一种用法就是在处理某一个 web 请求时, 匹配路由对应的处理函数.例如咋 gin 框架中一般是在对应路由上传递一个匿名函数, 但是也可以定义好一个处理函数,然后直接传入该函数的函数名, 因为之前提到过, 函数作为一种类型, 其函数名就是他的变量名\n函数作为返回值的高阶函数一般是用于闭包上.\n匿名函数不带函数名的函数, 语法格式如下\nfunc(参数列表) (返回值列表) &#123;&#125;\n\n匿名函数的参数列表要紧靠 func 关键字, 当返回值列表只有一个返回值时, 括号可以省略.\n闭包所谓闭包是指: 函数+ 引用环境.\n什么是引用环境? 是指作为返回值的函数内部, 使用并返回了其外部函数的变量. \n此时, 这个外部函数返回的函数称为闭包.\n在闭包的生命周期内, 他引用的环境(他外部函数的变量)将始终存在.\n闭包实例1// 实现一个加法器闭包\nfunc adder() func(int) int &#123;\n\tx := 0\n\treturn func(y int) int &#123;\n\t\tx += y\n\t\treturn x\n\t&#125;\n&#125;\n\nfunc main() &#123;\n\ta := adder()\n\tlog.Println(a(10))\n\tlog.Println(a(20))\n  \n  a2 := adder()\n  log.Println(a(30))\n\tlog.Println(a(40))\n&#125;\n\nadder()是一个返回闭包的函数, 内部带有闭包的引用环境x, 当每次调用闭包函数时, 相同闭包共享同一个引用环境, 所以 x的值被记录下来, 直到这个闭包函数被回收. a 与 a2 是两个不同的闭包.\n闭包实例 2func makeSuffix(suffix string) func(string) string &#123;\n  return func(fileName string) string &#123;\n    if !strings.HasSuffix(fileName, suffix) &#123;\n      return fileName + suffix\n    &#125; else &#123;\n      return fileName\n    &#125;\n  &#125;\n&#125;\n\nfunc main()&#123;\n  b := makeSuffix(\".jpg\")\n\tfmt.Println(b(\"b.jpg\"))\n\tfmt.Println(b(\"ax\"))\n&#125;\n\n// 这里再贴上 strings 包中的 HasPrefix 和 HasSuffix 的源码\n// 本质还是切片操作. 就是这么朴实无华且枯燥\n// HasPrefix tests whether the string s begins with prefix.\nfunc HasPrefix(s, prefix string) bool &#123;\n\treturn len(s) >= len(prefix) &amp;&amp; s[0:len(prefix)] == prefix\n&#125;\n\n// HasSuffix tests whether the string s ends with suffix.\nfunc HasSuffix(s, suffix string) bool &#123;\n\treturn len(s) >= len(suffix) &amp;&amp; s[len(s)-len(suffix):] == suffix\n&#125;\n\n总结:\n在闭包中, 只需主要,内部返回的函数需要将外部引用环境一并返回才能保证闭包的特性. 外部引用环境可以是外部函数的形参.\ndefer 语句defer 关键字会将其后跟随的程序语句延迟处理. 在 defer 修饰的函数即将返回时, 所有被延迟处理的语句执行顺序为 defer 定义顺序的逆序. 类似于栈的后进先出原则. 简言之:先定义的 defer 后执行,后定义的 defer 语句先执行.\n// 简单例子\nfunc main() &#123;\n\tfmt.Println(\"start...\")\n\tdefer fmt.Println(\"1...\")\n\tdefer fmt.Println(\"2...\")\n\tdefer fmt.Println(\"3...\")\n\tfmt.Println(\"end...\")\n&#125;\n// 输出结果为\n// star...\n// end...\n// 3...\n// 2...\n// 1...\n\n因为 defer 具备的这种延迟处理的能力, 所以常用于与资源释放有关的场景,比如释放数据库链接, 关闭打开的文件等\ndefer 执行的时机在 Go 中, return语句并非原子操作(不可在分割,必须完成执行完成的操作), 在底层,return 语句分成两步:\n\n给返回值赋值\nreturn x这一操作中, 先将x 的值赋值给真正的返回值.\n\nRET 指令\n真正的将返回值返回\n\n\ndefer 语句执行的时机是在 RET 操作之前, 赋值返回值之后.\ndefer 修饰的函数一个函数如果未指明返回值的变量名,而且返回值以变量方式返回, 那么函数内部如果存在 defer 修饰的函数操作了最终的返回值,则实际的返回值仍然是原来的返回值. defer 语句的操作不影响返回结果. 这是因为 defer 发生在返回值赋值过程之后, 如果未指明变量名, 则 return 语句已经把结果返回给了内存, 这时,再对变量操作也不会再有新的值被返回,只能等待 defer 之后的 RET 操作返回之前的返回值.\nfunc f1() int &#123;\n\tx := 5\n\tdefer func() &#123;\n\t\tx++\n\t&#125;()\n\treturn x\n&#125;\n\n这段代码的最终返回值仍然是 5\n一个函数如果指明了返回值的变量名, 且返回值以常量形式返回时, 这个常量在 return 操作时将被赋值给指明了的返回值变量.然后执行 RET 操作.如果此时存在 defer 语句操作这个返回值变量名, 那么由于这个变量名就是指向最终返回值的一块内存,defer 中的操作会影响最终的返回值结果.\nfunc f2() (x int) &#123;\n\tdefer func() &#123;\n\t\tx++\n\t&#125;()\n\treturn 5\n&#125;\n\n这段代码的最终结果为 6\n代码总结:上述代码的区别在于一个内部包含 defer 语句操作返回值的函数是否指定了返回值名称. 如果指明了返回值名称,则这个变量名会指向一块分配好的内存来存储返回值. 若未知名返回值名称, 在函数返回时同样会分配一块内存存储返回值,但是没有额外的变量来表示它.\nf1()中返回的是一个由局部变量表示的值, 在 return 时, 这个 x 的值被赋值给了一块没有显式变量表示的内存. defer 对 x 的操作并不影响返回值的那块内存.只影响 x 的局部变量所在的内存. 所以返回值不收影响.\nf2()中, 由于显式的声明了返回值的一个变量名,所以在函数返回时,常量被赋值给了 x, 而 x 就标识着返回值所在的那块内存, 如果对这个变量进行操作, 就会影响最终的返回值.\ndefer 的另一特性用 defer 注册延迟处理的函数时,函数的所有参数值都必须被确定. 如果有计算,就要得到计算结果后再注册.\ndefer 修饰的函数参数被注册后,就不可再被更改了.\nfunc calc(index string, a, b int) int &#123;\n\tret := a + b\n\tfmt.Println(index, a, b, ret)\n\treturn ret\n&#125;\nfunc main() &#123;\n  x, y := 1, 2\n\tdefer calc(\"AA\", x, calc(\"A\", x, y))\n\tx = 10\n\tdefer calc(\"BB\", x, calc(\"B\", x, y))\n\ty = 20\n&#125;\nA 1 2 3\nB 10 2 12\nBB 10 12 22\nAA 1 3 4\n\n上述代码中首先执行了第 8 行的第三个参数处的函数调用, 并且将其返回值确定后用于 defer 注册, 此时 defer 注册的外部函数的三个参数分别为AA x=1 3.\n接着执行 第9行. 需要注意的是,即便 x 的值被更改了, 但 defer 注册了的函数实参并不会被改变. 第 8 行处 x 的值仍然是注册时的值 1. \n接着执行第 10 行中的第三个参数处的函数调用,此时 还未进行注册, 需要先确定函数的返回值,因此 x 的值为 10, y 的值为 2, 返回值为 12. 然后进入到 defer 注册过程, 外部函数的参数需要被确定下来,BB x=10 12.\n然后执行 y=20, 虽然 y 执行了,但 defer 注册后并未再使用该值,所以紧接着执行 defer 注册.\n根据 defer 机制,先执行第2个 defer, 也就是&quot;BB&quot;这一行,这里 x 的值为 10, 函数返回值为 12, 所以最终打印结果是 22.\n紧接着执行第1 个 defer, x=1, 返回值为 3, 所以最终的打印结果是 4\n","slug":"Golang-Tutorial-9","date":"2021-09-15T09:37:40.000Z","categories_index":"Golang","tags_index":"Programming Language","author_index":"Hccc丶"},{"id":"b7b9075ba8f3fce9f65889bb535dd257","title":"Golang Tutorial 8","content":"Golang Tutorial 8类型的 String 方法和格式化描述符String()方法当定义了一个具有很多方法的类型时, 常常也会实现一个 String()方法来定制类型的字符串形式的输出. 如果一个类型定义了 String()方法,那么它会被 fmt.Printf()当成是默认输出. 等同于使用%v 产生的输出格式. fmt.Println 和 fmt.Print 也会使用这个 String()方法.\n换句话说,当想要为一个类型定制一个可以由 %v 形式输出的字符串. 就得实现 String 方法\ntype Dog struct &#123;\n  name string\n&#125;\n\nfunc NewDog(name string) *Dog &#123;\n  return &amp;Dog&#123;name: name&#125;\n&#125;\n\n// 定义 String 方法, 当使用 fmt.Println() 直接打印 Dog 类型的变量时, 会根据 String 方法\n// 的返回值返回相应的字符串.\n// 需要注意, String 是方法,需要一个接收者\nfunc (d *Dog) String() string &#123;\n  // 这里定义直接返回类型名\n  return \"Dog\"\n&#125;\n\n当使用指针类型实现了 String 方法后,如果在实际传参时给一个值类型,则 fmt.Println 等方法不会调用 String 方法.而是用默认的输出格式.\n因此为了规范统一,当使用指针类型接收者时, 就创建结构体指针,如果是值类型接收者,就创建结构体的值\n使用值接收者和指针接收者实现接口的差异当定义好了接口之后, 需要类型去具体实现接口中的方法. 方法的接收者类型在之前已经学过, 分为值类型和指针类型. 二者在接口类型的变量上表现有哪些差异呢?\n值类型接收者实现接口当使用值类型接收者实现了接口中的所有方法后, 可以让接口变量去直接接收该类型的普通变量或者是指针变量.\n指针类型接收者实现接口当使用了指针接收者实现了接口中的方法, 那么使用接口变量再去接收改类型的普通变量时,编译无法通过,会告知你必须接口变量只能接收指针类型的接收者.\n重点:\n为保证作为 gopher 的职业生涯: 请始终牢记, interface 在 go 中也是一种类型\n空接口:空接口是指没有定义任何方法的接口。因此可以认为是任何类型都实现了空接口。\n所以空接口变量可以接收任意类型的变量.\n类型断言检测在程序运行时, 接口变量中实际存储的变量类型是什么.\n断言语法:v, ok := iVal.(T). i前缀表示此变量是一个接口变量, 这个语法和 map 类型判断是否含有特定 key 的语法类似, 当 iVal 中实际存储的变量类型为 T 时, 则 v 就是接口变量iVal 转换为类型 T 的值, 且有 ok=true. 否则就是类型 T 的 0 值, 且 ok=false.\nif v, ok := iVal.(T); ok &#123;\n  Process(v)\n  return\n&#125;\n\n使用 type-swithc 来进行多值类型判断在使用 switch 做类型断言时, 括号内一定是使用 type 关键字\nswitch t := iVar.(type) &#123;\n  case *Square:\n  \tfmt.Println(t)\n  case *Circle:\n  \tfmt.Println(t)\n  case *Rectangle:\n  \tfmt.Println(t)\n  case default:\n  \tfmt.Println(t)\n&#125;\n\niVar 是一个接口类型变量, 当程序运行时会接受一个具体的类型传入, 此段程序就用于判断该接口变量实际存储的具体是什么类型, 并拿到该类型对应的值 t.\n若指向单纯的判断接口中实际接收的类型, 可以省略 t.代码如下\nswitch iVar.(type) &#123;\n  case *Square:\n  \tfmt.Println(t)\n  case *Circle:\n  \tfmt.Println(t)\n  case *Rectangle:\n  \tfmt.Println(t)\n  case default:\n  \tfmt.Println(t)\n&#125;\n\nswitch 后面可以跟一个变量, case 可以跟一个或者多个常量表达式.\n","slug":"Golang-Tutorial-8","date":"2021-09-14T10:10:28.000Z","categories_index":"Golang","tags_index":"Programming Language","author_index":"Hccc丶"},{"id":"de3eee39821c26516f0a3be9bd55d485","title":"Golang Tutorial 7","content":"Golang Tutorial 7 继承与多态Golang 中的继承在 Go 中,继承实际是由类型组合来实现的, 根据前一节的内容, Go 的结构体中支持匿名字段, 由类型名作为字段名,且在实际使用时, 可以被省略.\n下面以一个动物的例子来展示如何使用继承. 同时使用一个汽车的例子来表示组合\ntype Animal struct &#123;\n\tname string\n&#125;\n\nfunc (a *Animal) Cry() &#123;\n\tfmt.Println(a.name, \"are Crying\")\n&#125;\n\ntype Dog struct &#123;\n\tfeet int\n\t*Animal\n&#125;\n\nfunc NewDog(name string, feet int) *Dog &#123;\n\tanimal := new(Animal)\n\tanimal.name = name\n\n\treturn &amp;Dog&#123;\n\t\tfeet: feet,\n\t\t// 匿名字段在初始化时需要使用该字段的类型作为字段名\n\t\tAnimal: animal,\n\t&#125;\n&#125;\n\n// Override the Animal's Cry method\nfunc (d *Dog) Cry() &#123;\n\tfmt.Println(d.name, \"is a dog. He barks\")\n&#125;\n\nfunc (d *Dog) Run() &#123;\n\tfmt.Println(d.name, \"run to the window\")\n&#125;\n\ntype Bird struct &#123;\n\tfeet int\n\t*Animal\n&#125;\n\nfunc NewBird(name string, feet int) *Bird &#123;\n\treturn &amp;Bird&#123;\n\t\tfeet: feet,\n\t\tAnimal: &amp;Animal&#123;\n\t\t\tname: name,\n\t\t&#125;,\n\t&#125;\n&#125;\n\n// Override the Animal's Cry method\nfunc (b *Bird) Cry() &#123;\n\tfmt.Println(b.name, \"is a bird. He is tweeting\")\n&#125;\n\nfunc (b *Bird) Fly() &#123;\n\tfmt.Println(b.name, \"flying to the sky!\")\n&#125;\n\ntype Cat struct &#123;\n\tfeet int\n\t*Animal\n&#125;\n\nfunc NewCat(name string, feet int) *Cat &#123;\n\treturn &amp;Cat&#123;\n\t\tfeet:   feet,\n\t\tAnimal: &amp;Animal&#123;name: name&#125;,\n\t&#125;\n&#125;\n\nfunc main() &#123;\n\tdog := NewDog(\"黄四郎\", 4)\n\tdog.Cry()\n\tdog.Run()\n\n\tbird := NewBird(\"bili\", 2)\n\tbird.Cry()\n\tbird.Fly()\n\n\tcat := NewCat(\"mimi\", 4)\n\tcat.Cry()\n&#125;\n\n这个例子包含了一个 Animal 类, 一个 Dog 类, 一个 Bird 类型和一个 Cat 类型.\nDog, Cat 和 Bird 都内嵌了匿名字段Animal. 同时 Dog 和 Bird 都重写了 Animal 的 Cry 方法. 根据程序的运行结果可以知道, Dog 和 Bird 都实现了各自的 Cry 行为. Cat 未重写 Animal 的 Cry 方法, 所以仍然使用了 Animal 的 Cry 方法.\n同时需注意的是:实际在 cat 对象中调用 Cry 的过程为 cat.Animal.Cry,  由于Animal 字段是 Cat类型中的匿名字段,所以被省略了.\nGolang 中的多态OOP 中的多态核心概念为: 父类引用指向具体的子类对象. 这一概念包括了变量的声明以及形参的定义.\n在 go中由于没有显式的继承概念,所以并无父类与子类的概念, 因此想要实现多态, 需使用另外的语言特性.也就是接口.\n接口简单理解接口就是一系列方法(现实中某一类型的行为)集合, 在接口中,只允许方法的定义(声明), 包括参数列表和返回值列表,但不包括具体实现.\nGo 中的接口语法为: 凡是实现了接口中所有的方法的类型都可以被指向接口类型, 只实现接口中部分方法的类型不能被接口类型变量所指向.\npackage main\n\nimport \"fmt\"\n\ntype SmartPhone interface &#123;\n\tCall()\n\tSendMsg()\n\tSurfing()\n\tGetSeries() string\n&#125;\n\ntype IPhone struct &#123;\n\tSeries string\n\tsize   float64\n&#125;\n\nfunc NewIPhone(series string, size float64) *IPhone &#123;\n\treturn &amp;IPhone&#123;\n\t\tSeries: series,\n\t\tsize:   size,\n\t&#125;\n&#125;\n\n// IPhone 实现了 SmartPhone接口中的全部方法\nfunc (i *IPhone) Call()    &#123;&#125;\nfunc (i *IPhone) SendMsg() &#123;&#125;\nfunc (i *IPhone) Surfing() &#123;&#125;\nfunc (i *IPhone) GetSeries() string &#123;\n\treturn i.Series\n&#125;\n\ntype Nokia struct &#123;\n\tSeries string\n\tsize   float64\n&#125;\n\nfunc NewNokia(series string, size float64) *Nokia &#123;\n\treturn &amp;Nokia&#123;\n\t\tSeries: series,\n\t\tsize:   size,\n\t&#125;\n&#125;\n\n// Nokia 并未实现 Surfing 方法\nfunc (n *Nokia) Call()    &#123;&#125;\nfunc (n *Nokia) SendMsg() &#123;&#125;\nfunc (n *Nokia) GetSeries() string &#123;\n\treturn n.Series\n&#125;\n\nfunc Buy(smartPhone SmartPhone) &#123;\n\tfmt.Printf(\"I bought a(n) %v \\n\", smartPhone.GetSeries())\n&#125;\n\nfunc main() &#123;\n\tiphone := NewIPhone(\"IPhone 13\", 6.7)\n\tBuy(iphone)\n\n\tnokia := NewNokia(\"Nokia 15.6\", 3.6)\n\t// cannot use nokia (variable of type *Nokia) as SmartPhone value in argument to Buy:\n\t// missing method Surfing\n\tBuy(nokia) // 此行报错\n&#125;\n\n\n根据上述代码在编译期间的结果, Nokia 未实现 Surfing 方法, 因此不能被当做是一个 SmartPhone 接口的变量.无法传入到 Buy 函数中去.\n结论: 只有实现了接口中所有方法的类型才能被接口类型接收.\n","slug":"Golang-Tutorial-7","date":"2021-09-14T07:52:44.000Z","categories_index":"Golang","tags_index":"Programming Language","author_index":"Hccc丶"},{"id":"eaefd71f93a58b7ced195ad6747e390e","title":"Golang Tutorial 6","content":"Golang Tutorial 6Struct结构体结构体定义基本语法使用 type 和 struct 关键字来定义一个自定义的类型.\ntype Name struct&#123;\n  field1 type1\t`json:\"field1\"`\n  field2 type2\t`json:\"field2\"`\n  ...\n&#125;\n\n在程序中声明结构体类型的变量声明变量type Student struct &#123;\n  name \t\t\tstring\n  age \t\t\tint\n&#125;\n\nfunc main() &#123;\n  var s1 Student\t\t// 先声明一个结构体类型的变量.然后进行赋值\n  s1.name = \"张三\"\n  s1.age = 19\n&#125;\n\n使用 new 声明结构体变量指针go 中提供了一个语法糖, 针对结构体类型的变量, 无论是普通变量还是指针变量, 都可以直接使用.号直接访问字段.\n// var s2 *Student\n// s2 = new(Student)\ns2 := new(Student)\ns2.name = \"李四\"\ns2.age = 20\n\n需要注意的是不论new 还是直接声明结构体变量, 编译器都会为 struct 类型分配内存,因其是值类型的.\n显式初始化显式初始化的语法和 map 的显示初始化类似,不过 map 的初始化是以 key-value 形式出现,所有 key 类型都是一致的. 而结构体的内部成员冒号前面是字段名,冒号后是字段值.\ns3 := &amp;Student&#123;name:\"王五\", age:20&#125;\ns4 := &amp;Student&#123;\n  name:\"汤师爷\",\n&#125;\n\n在 s4 的声明过程中, 这种声明方式可以省略部分字段,由编译器来赋一个对应类型的 0 值.\n注: new 的作用等同于&amp;Student&#123;&#125;这样声明一个未初始化的结构体变量.\n结构体的内存布局在 go 中,结构体和它所包含的数据是被存放在连续的内存块中的,且存在一个内存对齐的机制来保证其高效性. 内存对齐机制,大致可以理解为按照一个对齐系数来对齐这块内存,如果结构体内部的数据类型之间的偏移量不是 对齐系数的整数倍,就需要补充一定的内存使其对齐.\n使用工厂方法创建结构体实例使用工厂方法创建结构体,也可以叫做为结构体类型创建构造器. 一般来说根据结构体内部的成员来显式地创建并返回一个结构体变量.工厂方法的一般规则为用New+类型名作为工厂方法, 成员变量为参数.\ntype Student struct &#123;\n  name string\n  age int\n&#125;\n\nfunc NewStudent(name string, age int) *Studnet &#123;\n  if name == \"\" &#123;\n    return nil\n  &#125;\n  return &amp;Student&#123;name:name, age:age&#125;\n&#125;\n\n// 使用 new 的 构造函数或工厂方法\nfunc NewStudent(name string, age int) *Student &#123;\n  if name == \"\" &#123;\n    return nil\n  &#125;\n  student := new(Student)\n  student.name = name\n  student.age = age\n  return student\n&#125;\n\n匿名字段与内嵌结构体go 语言结构体可以包含一个或者多个匿名字段,简言之,匿名字段就是没有字段名,只有字段类型. 而此时,类型名就是字段名. 匿名字段也可以是一个结构体类型, 从而有了所谓的内嵌结构体.\n在每一个结构体中,因为字段名必须唯一, 所以同种数据类型只能有一个匿名字段.\n而匿名字段这一特性在 go 中被用来模拟 OOP 中的继承行为. 在 go 中,继承是通过内嵌结构体和类型组合来实现的.\ntype Address struct &#123;\n  Province \tstring\n  City \t\t\tstring\n&#125;\n\ntype Person struct &#123;\n  name string\n  age int\n  Address\t\t// 嵌套一个匿名字段\n&#125;\n\nfunc main() &#123;\n  p1 := new(Person)\n  p1.name = \"张麻子\"\n  p1.age = 40\n  p1.Address.Province = \"广东省\"\n  p1.City = \"鹅城\"\t\t// 省略了内嵌匿名字段名\n  fmt.Println(p1)\n&#125;\n\n从上述代码可以看出, 当访问匿名字段类型内的数据时,可以省略这个匿名字段,直接由外部类型来访问内嵌匿名类型的字段.\n类型方法Go 中所说的方法是作用在一个叫做 receiver 上的函数. Receiver(接收者)是特定类型的变量或者指针变量. 它绑定了函数来展示它所具备的功能.\n当前的go 版本 1.17支持值类型变量或者指针变量调用值类型接收者的方法或者指针类型接收者的方法. 没有限制. 但个人认为在不涉及修改结构体实例的内部数据时,使用值类型接收者.\ntype Dog struct &#123;\n  name string\n&#125;\n\n// 构造一个工厂方法或者叫构造函数\nfunc NewDog (name string) *Dog &#123;\n  return &amp;Dog&#123;name:name&#125;\n&#125;\n\n// 设置改变私有变量的导出方法.\nfunc (this *Dog) SetName(name string) &#123;\n  this.name = name\n&#125;\n\n// 值类型接收者以及方法\nfunc (d Dog) GetName() string &#123;\n\treturn d.name\n&#125;\n\nfunc (this *Dog) move() &#123;\n  fmt.Println(this.name, \"move to the door\")\n&#125;\n\ntype Leader struct &#123;\n\tname string\n&#125;\n\nfunc NewLeader(name string) *Leader &#123;\n\treturn &amp;Leader&#123;name: name&#125;\n&#125;\n\nfunc (l *Leader) CleanUpBandit() &#123;\n\tfmt.Println(\"县长来了, 枪在手, 跟我走\")\n&#125;\n\n关于何时使用指针接收者\n当需要修改接收者中的值时\n当接收者是拷贝代价比较大的大对象\n当某个方法使用了指针类型的接收者时, 其他方法最好也是使用指针类型的接收者\n\n","slug":"Golang-Tutorial-6","date":"2021-09-13T04:16:04.000Z","categories_index":"Golang","tags_index":"Programming Language","author_index":"Hccc丶"},{"id":"21b7afb55dd7403da1611146a47b852e","title":"Golang Tutorial 5","content":"Golang Tutorila 5Map Tutorialmap 在 go语言中也是一种引用类型, 因此多使用 make 函数来创建.\n基础语法格式var m map[keyType]valueType\n\nvar studentId map[string]int\n\n同 slice 一样,如上述格式声明 map 类型后,打印结果显示,编译器为 studenId 变量分配了内存地址,但是并没有赋初值(未初始化,值为nil). 因为 map 是引用类型,需要使用 make 来为其赋初值.\n对一个值为 nil 的 slice 中添加元素是可行的, 具体做法便是使用 append 函数. 但是对于 map 来说不行.会引发 panic\nmake 方式声明 map 类型变量c = 5 // 显式指定 map 中的k-v 对的数\nvar m2 = make(map[string]int, c)\nm3 := make(map[string]string, 10)\n\n当声明完后, 此时 map 变量已经被分配了内存, 但由于未添加元素,所以是一个空的 map 但不是 nil\nmap 的 key 和 value 字段的要求key 允许的类型为 string, int, float, 或者内部字段全部为基本数据类型的结构体(目前很少用到), value 可以是任意值. 可以定义为一个空接口类型来接收各种类型的值. 因为函数在 go 中为一等公民, 因此 value 也可以接收函数类型的值. 换言之, 可以传入函数名作为 value, 这样就可以通过 key 来指定具体执行的函数,从而进行流程上的控制.\nfunc add(a, b float64) float64 &#123;\n\treturn a + b\n&#125;\n\nfunc sub(a, b float64) float64 &#123;\n\treturn a - b\n&#125;\n\nfunc mult(a, b float64) float64 &#123;\n\treturn a * b\n&#125;\n\nfunc divide(a, b float64) float64 &#123;\n\treturn a / b\n&#125;\n\n// 定义 value 为函数类型. 此处value 可以使用括号也可以不使用\nvar m3 = make(map[string] (func(float64, float64) float64) )\n\nm[\"+\"] = add\nm[\"-\"] = sub\nm[\"*\"] = mult\nm[\"/\"] = divide\n\nfmt.Println(m[\"+\"](1, 2))\n\n注: 函数也是 go 中的一种类型.可以将函数名当做函数类型的常量,可将函数明作为参数或者值传给另一些变量或者函数参数中. 在函数章节中会详细介绍.\n判断 map 中是否存在特定 key首先掌握 map 通过 key获取 value 的语法.\nvalue, ok := m[\"key\"]\n\n上述语法第一个参数为 key 对应的 value, 第二个 ok 表示 key 存在与否,当不存在时,返回 false. 存在时返回 true.\n通过上述的语法,go 中常用的用于判断某个 key 是否存在的语法如下\nif _, ok := m[\"key\"]; !ok &#123;\n  fmt.Println(\"there is no such key in m\")\n&#125;\n\n用 slice 作为 value一个应用场景为: 当以 key 为父进程的 pid 时,所有该进程的子进程(子进程 pid)就需要用 slice 来存储.\n另外需要注意的是,由于 value 也是一个引用类型,因此在使用时需要预先进行一次 make 初始化内存操作.一面报错.\nm2 := make(map[int][]int)\nm2[1] = make([]int, 5)\n\nfor i := 0; i &lt; len(m2[1]; i++)&#123;\n  m2[1][i] = i+1\t\t// 简单对 1 对应的 slice 中的元素赋值\n&#125;\n\n获取 map 中元素的个数使用 len 函数可以获取到 map 中存储的 k-v 对个数.\n对 map 的排序map 中的 key 和 value 都是无序的,如果想要对 map 排序,需要先将 map 中的 key 或者 value 取出存入一个 slice 中,然后利用sort 包对 key 进行排序. 再用循环打印出想要的序列.\n但经过测试, 在 map 中添加元素后,默认的排序方式是按照字符串首字母对应的 byte值(ASCII 码值)或者 rune 值(unicode 值)进行排序, 然后根据值得大小从小到大输出的.\nm2 := make(map[string]int)\nm2[\"Apple\"] = 100\nm2[\"Banana\"] = 101\nm2[\"cherry\"] = 102\nm2[\"date\"] = 103\nm2[\"John\"] = 101\nm2[\"Tom\"] = 102\ni := 0\nfor k, v := range m2 &#123;\nfmt.Println(k, v)\nm2[k] = 200 + i\ni++\n&#125;\nfmt.Println(m2)\n\n再看如下一段代码\nm := make(map[int]*int)\nstus := []int&#123;1, 2, 3, 4, 5&#125;\n\nfor idx, stu := range stus &#123;\n  m[idx] = &amp;stu\n&#125;\nfor k, v := range m &#123;\n  fmt.Println(k, \"=>\", *v)\n&#125;\nfmt.Println(m)\n\n这段代码最终的输出结果是所有的 key 对应的 value 都为 5, 因为其 value 部分保存的都是循环体变量的指针. 当range循环体变量循环到最后一个 slice 元素后, 复制最后一个元素的副本, 然后被保存到了 map 的 value 部分中.\n这里有两点需要注意: 1. 因为 map 变量的 value 保存了 int 的指针,所以, 循环体变量再循环到最后一个 slice 元素后并未被释放内存. 2. 因为value 保存的是地址, 循环变量的地址是指向 slice 最后一个元素的副本,因此输出结果与 slice 最后一个元素的地址也是不同的.\n","slug":"Golang-Tutorial-5","date":"2021-09-12T12:18:36.000Z","categories_index":"Golang","tags_index":"Programming Language","author_index":"Hccc丶"},{"id":"ed56a0be6c67a53488e6ffd0f75904e2","title":"Golang Tutorial 4","content":"Golang Tutorial 4切片(slice)Golang 中的切片是对数组一个连续片段的引用, 因此是引用类型. 这个连续的片段可以是整个数组,也可以是由开发者指定的开始和结束索引限定的一段连续片段. 从集合的角度来看,若数组是一个元素集合,则切片就是它的一系列非空子集.\n既然是数组的引用,那么切片本身也具备数组的一些性质.另外,切片同时也具备一些数组不具备的特质,比如可以向切片中增加元素.\n切片同时提供了可以计算切片容量的函数 cap(), 如果切片是由数组创建的, 计算方法是从切片的起始元素到数组末尾的长度.\n创建切片的方式make创建// 创建格式: make(type, len[, cap])\n// 创建一个长度为 5, 容量为 10 的切片\n// 切片容量代表的是当切片元素达到 5 时, 继续往后最多可添加的元素个数\n// 当再添加五个元素后,切片容量达到最大,此时若再向其中添加元素,则需要重新构建\n// 新的切片.因此, 在一些结构体中,可能需要使用指针接收者来指向原始的切片数据\ns1 := make([]int, 5, 10)\n\n// 切片的遍历\nfor idx, value := range s1 &#123;\n  fmt.Println(idx, value)\n&#125;\n\n显式初始化var sli1 = []int&#123;1,2,3,4,4&#125;\nsli2 := []string&#123;\"zhangsan\", \"lisi\", \"wangwu\"&#125;\n\n从数组中创建arr1 := [...]int&#123;1,2,3,4,5&#125;\nsli3 := arr1[1:3] // 方括号中的索引是包含左边不包含右边的\n// sli3 的输出结果是 2 3\n\ncopy函数利用 copy 函数可以对一个已有的切片进行拷贝,具体语法如下\nrst := make([]string, 5, 10)\ntemp := []string&#123;\"Beijing\", \"London\", \"Glasgow\"&#125;\n// copy 函数会将后续参数中的元素全部复制到第一个参数的切片中\n// copy(dest, src) // 将 src 中的元素拷贝到 dest 中\ncopy(rst, temp)\n\nappend 函数append 函数会将0 个或者多个具有相同类型的元素追加到已有的切片中,若超出了切片的容量时, 切片会发生扩容, append 会重新分配一块新的内存区域来存放整个新的切片.此时旧的切片将保持扩容到最大容量时的数据. append 函数总是成功返回的,除非内存消耗殆尽.\ns1 := make([]int, 2, 4)\nvar s2 []int\nfmt.Printf(\"%p \\n\", s2)\t//打印初始的s2 地址,由于未初始化,并未分配实际的内存地址\nfor i := 0; i &lt; 5; i++ &#123;\t// 此处设置 5 是为了测试当容量超出原始 slice 的容量时,看append 函数是否会对 slice 进行扩容并分配新的内存空间给新变量\n  if i >= len(s1) &amp;&amp; i &lt; cap(s1) &#123;\n    fmt.Println(\"长度不足,在 slice 容量内扩容\")\n    s1 = append(s1, i)\n    fmt.Printf(\"%p %v \\n\", s1, s1[i])\n  &#125; else if i &lt; len(s1) &#123;\n    fmt.Println(\"长度足够, 直接对 slice 元素赋值\")\n    s1[i] = i\n    fmt.Printf(\"%p %v \\n\", s1, s1[i])\n  &#125; else &#123;\n    fmt.Println(\"元素个数已超出原始 slice 容量, append 函数重新分配内存空间给新的 slice\")\n    s2 = append(s1, i)\n    fmt.Printf(\"%p %v\\n\", s2, s2[i])\n    fmt.Printf(\"len(s2)=%v cap(s2)=%v \\n\", len(s2), cap(s2))\n  &#125;\n&#125;\nfmt.Printf(\"%p %v\\n\", s1, s1)\nfmt.Printf(\"%p %v\\n\", s2, s2)\n\nslice 的扩容规则根据上述代码的输出结果,最终 cap=4 的 s1 在容量不足进行扩充后,s2 容量为 8.因此扩容规则为 double 原始 slice 的容量 capacity.\nnew 函数和 make 函数的区别new 函数会分配指定类型的指针给变量. 多用于结构体类型和数组等值类型变量, 相当于&amp;T&#123;&#125;,其中 T 可以是[5]int, [6]string以及 &amp;Student&#123;&#125;等自定义类型.\nnew 函数创建的指针变量值为 0x0, 若为 silce, 则 len=0, cap=0. 变量指向的实际 slice 为一个nil.而 slice 的 nil 输出为一个[].\nmake 会初始化一个slice 变量, 并分配实际内存, 创建对应类型的初值. 在不指定 cap 的时候,cap 会与 len 相等.\ntemp1 := new([]int)\nfmt.Printf(\"%p %v %v %v\\n\", *temp1, *temp1, len(*temp1), cap(*temp1))\nfmt.Println(*temp1 == nil)\ntemp2 := make([]int, 5)\nfmt.Printf(\"%p %v %v %v \\n\", temp2, temp2, len(temp2), cap(temp2))\n\n可以根据上述代码自行检验结果.\n","slug":"Golang-Tutorial-4","date":"2021-09-05T22:06:48.000Z","categories_index":"Golang","tags_index":"Programming Language","author_index":"Hccc丶"},{"id":"3983d1b06f9cc59a424cf4b8b973001f","title":"Golang Tutorial 3","content":"Golang Tutorial 3数组(Array)在 golang 中,数组是值类型变量,当作为参数传递时,会发生值拷贝,在函数体内部对数组进行修改后,并不会影响函数体外的数据\n作为强类型语言, Golang 中的数组元素必须都是相同类型,此点与 python 的 list 有所区别\n同时,作为值类型的变量类型, go 提供了 new 关键字来为其分配指针.\nGolang 中声明数组的几种方式需要注意的是,声明数组时必须指定数组元素的个数,或者在方括号[]内使用...由编译器推断具体的数组元素个数\n直接声明var arr [5]int\n// 直接声明而不初始化时, 编译器默认为数组分配 0 值\n\n这种声明方式创建的 arr 变量类型是[5]int 类型, 当直接使用 arr 传参时, 会对 arr 进行值拷贝.\n初始化显式的为数组元素指定值,可以部分指定,余下的部分自动赋值 0 值\nvar arr1 = [10]int&#123;1,2,3,4&#125;\n\n使用指定索引的方式进行初始化,未被指定的部分赋值对应类型的 0 值\nvar arr2 = [5]int&#123;0:1, 3:5&#125;\n\n使用...指定数组,编译器自动推断数组元素个数, 这种指定方式必须带有初始化,否则报错.\nvar arr3 = [...]int&#123;1,3,4,5,6&#125;\n\n多维数组二维数组func main()&#123;\n\tvar array = [3][2]string&#123;\n    &#123;\"中国\", \"北京\"&#125;,\n    &#123;\"美国\", \"华盛顿\"&#125;,\n\t\t&#123;\"英国\", \"伦敦\"&#125;,\n\t&#125;\n\n\t// 使用两种方式遍历数组\n\tfor _, value := range array &#123;\n\t\tvar builder strings.Builder\n\t\tfor i := 0; i &lt; len(value); i++ &#123;\n      // 练习使用 strings.Builder 来拼接字符串\n\t\t\tbuilder.WriteString(value[i])\n\t\t\tbuilder.WriteString(\"-\")\n\t\t&#125;\n\t\tfmt.Println(builder.String())\n\t&#125;\n&#125;\n\n需要注意的是使用 range 方式遍历可迭代的类型时, value 都是可迭代变量中元素的副本,对他的修改不会改变原始数据\n数组可变因数组支持对其内部元素的更改, 因此称其为可变的\nvar arr1 [5]int\narr1[0] = 1\n\n","slug":"Golang-Tutorial-3","date":"2021-09-03T07:30:17.000Z","categories_index":"Golang","tags_index":"Programming Language","author_index":"Hccc丶"},{"id":"f20d4f48999b3be7c6a4f7d5c95630f9","title":"Golang Tutorial 2","content":"Golang 的 String 详解本章介绍 Go 语言中 string 相关的内容. 包括字符串创建, 修改, 遍历和转换等操作\n\n\nUnicode in Go在 go 中支持 Unicode(UTF-8), 因此字符也称为 Unicode 码点或者runes, 在内存中用 int32 表示.但具体每隔字符占据多少字节是不一样的.一个中文在 go 中占据 3 个字节.\nrune 类型与 byte 类型rune 类型在 go 语言底层实现是一个 int32类型, 它仅仅是一个 int32 的别名. byte 类型底层实现是一个 uint8类型.它也是一个别名\ntype byte = uint8\ntype rune = int32\n\n零值String 类型的 0 值是一个长度为 0 的字符串&quot;&quot;.因为 go 中 string 是值类型,所以 0 值不是 nil,无法与 nil 进行比较.\n字符串比较一般的字符串比较, 实际是通过在内存中比较字节来实现的. 比如&gt;=, &lt;= , == , !=.\n字符串单个字符的获取字符串单个字符的获取可以通过索引的方式[]来获取,但需要注意的是,在中文字符中,由于一个字符占据三个字节,所以一定要知道在包含中文的字符中,两个字符之间的索引间距不一定是 1,可能是 3\n使用 range 遍历字符串在使用 range 遍历字符串时,以字符为单位进行遍历,也就是说,在返回的 i, 和 v 中,i 的值并不都是规律的\n字符串拼接+ 拼接使用这种拼接方式的缺点在于: 字符串一旦定义就不可更改,有时为了获取最终字符会产生很多的无用字符串,为程序带来 gc 的压力,性能相对较差.\nstr1 := \"hello\"\nstr2 := \"world\"\nstr3 := str1 + str22\n\n使用 fmt.Sprintf()此函数内部逻辑较为复杂,判断条件众多, 使用[]byte 实现,性能一般\nfmt.Sprintf(\"%d %s\", 2021, \"年\")\n\nstrings.Join()strings.Join([]string&#123;\"你好\", \"golang\"&#125;, \"-\")\n\n此函数会根据字符串切片的内容,计算一个拼接之后的总长度,然后申请对应内存大小的内存区域,一个个的填入拼接后的字符串.\n在已有一个字符串切片的情况下,这个效率很搞,但是若本身并没有待拼接的字符串时,创建该数组的代价很大.\nJoin 函数在拼接字符串时,会在每个切片元素之间插入一个空字符串&quot;&quot;, 然后根据第二个参数指定的字符串进行替换.\nvar arrKeyValue = [5]string&#123;2: \"Chris\", 4: \"Ron\"&#125;\nfmt.Println(strings.Join(arrKeyValue[:], \",\"))\n\n上述代码利用指定数组元素索引的方式初始化了数组,然后利用切片特性将数组转化为切片.输出结果为\n,,Chris,,Ron \n// Ron 前面一个逗号是 Join 函数添加的,因为要在两个字符之间添加一个空字符串\n// Chris 前的两个逗号和后面的第一个逗号是原本初始化数组时默认给定的字符串 0 值\n// 在Join 函数内统一将 \"\" 替换为了指定的字符串\n\nbytes.Buffer()与 strings.Builder()在介绍 bytes.Buffer 和 strings.Builder()之前,先讨论一下 Golang 中的 Pointer 类型, 以及通过 Pointer 对同一块内存数据进行类型转换的方式.\nunsafe.Pointerunsafe.Pointer 代表任意一种类型的指针, 它有四种特殊操作:\nA pointer value of any type can be converted to a Pointer\nA Pointer instance can be converted to a pointer value of any type.\nA uintptr can be converted to a Pointer.\nA Pointer can be converted to a uintptr.\n\n类型转换模式上述的四个操作意思可以简单对应于如下形式\n*T1 => Pointer => *T2\n\n借助Pointer,可以实现一个指针类型的变量到另一个指针类型变量的转换.在这种转换模式中需要保证的是转换后指针类型的T2 的内存 &lt;= T1 的内存. 而且,转换前后两个类型的变量公用同一个内存数据.\nstring 和 []byte 转换var b = []byte&#123;'a', 'b', 'c', 'd'&#125; // 注意这里是单引号\n// 这个步骤就将一个 byte 的 slice 转换成了一个 string 变量,且二者公用同一个快内存数据.\n// 一旦 b 被更改,则 s 随之更改\n// 因为 string 本身是一个不可变的,所以不能对 s 做任何的修改操作.\ns := *(*string)(unsafe.Pointer(&amp;b))\nfmt.Println(\"b: \", b)\nfmt.Println(\"s: \", s)\n// 结果相同\n// 现在修改 b 中的数据\nb[3] = \"z\"\nfmt.Println(\"b: \", b)\nfmt.Println(\"s: \", s)\n// b 与 s 都发生了变化\n// 给 s 赋一个新的值, b 不会发生变化,因为 s 是 string 类型,赋新值会创建一个新的 string实例\ns = \"ABCD\"\nfmt.Println(\"b: \", b) // abcz\nfmt.Println(\"s: \", s) // ABCD\n\nbytes.Buffer和 strings.Builder 的用法// bytes.Buffer\nvar buffer bytes.Buffer\nbuffer.WriteString(\"hello\")\nbuffer.WriteString(\",\")\nbuffer.WriteString(\"中国\")\nbuffer.WriteString(\"!!!\")\nfmt.Println(buffer.String())\n\n// strings\nvar builder strings.Builder\nbuilder.WriteString(\"ABCD\")\nbuilder.WriteString(\"-\")\nbuilder.WriteString(\"EFGH\")\nfmt.Println(builder.String())\n\nstrings.Builder()底层实现func (b *Builder) String() string &#123;\n\treturn *(*string)(unsafe.Pointer(&amp;b.buf))\n&#125;\n\n由于是在同一块内存上操作,性能比 bytes.Buffer有所提升\n[]byte, []rune 与 string 的相互转化[]byte 与 string 的相互转化// []byte 转为 string\n// 第一种借助 unsafe.Pointer 方式转化\nvar bStr = []byte&#123;'a', 'b', 'c'&#125;\ns1 := *(*string)(unsafe.Pointer(&amp;bStr))\n// 第二种直接用类型转换强转\ns2 = string(bStr)\n\n// string 转为[]byte\nstr := \"这是 string\"\nbStr2 := []byte(str)\n// 这里的转换会创建一块新内存来对 bStr2 赋值,与 str 独立\n// 对 bStr3 的操作,不会影响原本字符串的数据\ns2 := \"hello Golang\"\nbStr3 := []byte(s2)\nfmt.Println(bStr3)\nbStr3[11] = 104\nfmt.Println(s2)\nfmt.Println(string(bStr3))\n\n从上述代码可以得到的结论: 直接使用类型转换时,会产生对原始数据的拷贝,因此对新数据的修改([]byte的修改,因为 string 是不可修改的)不会影响原本的字符串数据.\n换句话说,也正是为了保证 string 不可变的这种一致性,所以才会在进行类型转换时产生数据的拷贝\n[]rune 与 string 的转化​    []rune 与 string 的转化与[]byte 类似,只需要将 byte 换成 rune 即可\n","slug":"Golang-Tutorial-2","date":"2021-09-02T22:10:10.000Z","categories_index":"Golang","tags_index":"Programming Language","author_index":"Hccc丶"},{"id":"940d915bf94905eae8346cbc13db5243","title":"Golang tutorial 1","content":"Golang Tutorial 1Golang Constant Keywordsconst PI float64 = 3.1415926\n\n特殊常量: iotaconst (\n\ta = iota\t// iota 第一次出现时为 0,\n  b\t\t\t\t\t// b = 1\n  c\t\t\t\t\t// c = 2\n  d = 10\n  e\t\t\t\t\t// e = 10\n  f\t\t\t\t\t// f = 10\n)\n\n上述代码中的为 iota 的简单使用, iota 第一次出现时,初值为 0, 后续如果不为新的常量设置初值,则 iota 会递增, 直至遇到一个显式赋值的常量. iota 不在自增.\n典型的 iota 使用案例const Byte = 1\nconst (\n  _ = iota\n  KB = Byte &lt;&lt; (10*iota)\n  MB\n  GB\n  TB\n  PB\n)\n\nGolang variables Keywords在 go 中,所有的变量在定义之后,若没有显式赋值,则为该类型的0 值.\n如果只定义了变量而未在程序中使用,则编译不能通过\n/*\n\t第一种变量声明方式,\n\t对于基本类型来说,编译器可以直接进行推断,对于复杂类型,\n*/\nvar a int;\na = 10\nvar b float32 = 10.55\n\n/*\n\t第二种变量声明方式, 多用于函数体内\n*/\nc := \"Hello World\"\n\n/*\n\t一次性声明多个变量, 在声明变量时,括号内部如果为多行,则不需要等号\n*/\nvar (\n\ta int\n  b int\n  c float64\n)\n// 或者可以使用如下方式定义多个同种类型的变量\nvar a, b int\n\nGo 也支持对变量的同时(并行)赋值\na, b, c := 1,2, \"你好\"\n\n特殊变量// _ 下划线变量为一个只写变量,当我们有时不需要使用某些函数返回的部分返回值时,可以使用_来抛弃不需要的返回值\nfor _, value := range [1,2,3,4,5] &#123;\n  // 在使用 range 关键字时, 会对被遍历的可迭代元素产生两个值,\n  // 如果是 slice 或者 array, 则第一个值为元素索引,第二个值\n  // 为元素值.\n  // 如果被迭代对象为 map, 则第一个值为 key, 第二个值为 value.\n  // 如果是字符串, 则第一个值为单个 unicode 字符的起始索引,\n  // 因为 unicode 在 go 语言中占据长度不同, range 每次只能遍历一个字符,\n  // 所以,在 遍历字符串变量时, 第一个值可能并不连续.\n  fmt.Println(value)\t\n&#125;\n\nGolang Basic Datatypebool类型var varName bool = true\nif varName &#123;\n  fmt.Println(\"true\")\n&#125; else &#123;\n  fmt.Println(\"false\")\n&#125;\n\n数值型在 golang 中, 默认不写类型名时, 浮点数的类型为 float64. 与操作系统的位数有关.\nvar a1 int = 100\nvar a2 = 200\na3 := 300\nfmt.Println(a1, a2, a3)\n\nvar b1 float32 = 12.88\nvar b2 float64 = 3.1415926\nvar b3 = 8221.441  // 默认类型为 float64\nb4 := 741.245312353\n\n字符串golang 中的字符串是由单个字节连接起来的(英语字符), Go的字节使用 UTF-8编码来标识Unicode 字符集\nvar s1 string = \"Hello World\"\nvar s2 = \"你好, golang\"\ns3 := \"我爱学 go 语言\"\nfmt.Printf(\"s1: %v\\n\", s1)\nfmt.Printf(\"s2: %v\\n\", s2)\nfmt.Printf(\"s3: %v\\n\", s3)\n\n其他数字类型\n\n\nbyte 字节型\nuint8\n\n\n\nrune Unicode 字符编码\nint32\n\n\n值类型与引用类型golang 中引用类型只有三种slice, map和channel. \n其他的变量类型均属于值类型.\n值类型与引用类型变量的区别就是在函数传参时,是否会产生副本.\n因此诞生了两中传参方式: 值传递与引用传递.\n值传递: 当一个值类型变量传入函数时, 编译器首先复制该变量,产生一个副本,然后将副本传入到函数体内,在函数体内即便对这个副本进行了修改,也不会影响函数体外部的变量数据.\n引用传递: 当使用变量的引用(引用类型的变量名,地址或指针)向函数传参数时, 函数内部对于该变量的修改会影响外部的变量.也就是说,一旦函数体内部修改了这个变量,外部的变量也会随之更改.\n关于值类型与引用类型以及涉及到的内存逃逸分析,会有单独一篇介绍\n零值\n\n\n类型\n零 值\n\n\n\nint, uint8, int32, int64\n0\n\n\nfloat32, float64\n0.0\n\n\nbool\nfalse\n\n\nstring\n&quot;&quot;\n\n\nrune (int32)\n0\n\n\nbyte(uint8)\n0\n\n\ninterface\nnil\n\n\nmap[key]value\nnil\n\n\nslice\nnil\n\n\nchannel\nnil\n\n\n包的导入一般使用绝对路径或者从 github 上导入某个包,而不建议使用 ./方式引入包\n以下为几种导入包的操作.\n// 点操作\nimport (. \"fmt\")\n// 点操作的意义在于当导入了上述包之后, 在使用包中的函数时,不必再加上包名.\n//例如 可以将 fmt.Println() 简写成 Println()\nPrintln(\"hello\")\n\n// 别名操作, 类似于 python 中的 import xxx as X\n// 语法略有不同\nimport f \"fmt\" // import 后面的第一个变量为包的别名, 第二个为具体的包名\nf.Println(\"world\")\n\n包的初始化顺序在 import 包之后, 可以定义全局的常量或者变量.\n若想要使用 init 函数 (在 main 函数执行之前执行的函数,不可被调用), 则预先定义\n在init 函数之后, 可以定义若干函数体.\nGo 程序的启动顺序:go 程序的初始化和执行都起始于 main包. 如果 main 包中还包含了其他的包,则优先在编译时导入,当有多个包导入了同一个包,该包仅被导入一次.如果导入的某个包还包含了其他的包,则优先导入这些包,整体类似于深度优先搜索,然后对各级包中的包级别的常量进行初始化,接着执行 init 函数. 等到所有包都被加载完毕, 开始对 main 包中的包级别常量进行初始化.然后执行 main 包中的 init 函数(如果有的话), 最后执行 main 函数\n","slug":"Golang-Tutorial-1","date":"2021-08-29T21:34:48.000Z","categories_index":"Golang","tags_index":"Programming Language","author_index":"Hccc丶"}]